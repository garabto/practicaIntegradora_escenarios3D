<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Alienrinto VR</title>
    <link rel="icon" type="image/png" href="assets/icono.png">
    
    <style>
        /* -------- PORTADA INICIAL -------- */
        #portada {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            background-size: cover;
            background-blend-mode: overlay;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            text-align: center;
            padding: 20px;
        }

        #portada-content {
            max-width: 700px;
            background: rgba(0,0,0,0.6);
            padding: 40px;
            border-radius: 14px;
            box-shadow: 0 0 20px rgba(0,255,150,0.4);
            border: 1px solid #22ff88;
        }

        #portada h1 {
            font-size: 48px;
            color: #22ff88;
            margin-bottom: 10px;
        }

        #portada .sub {
            font-size: 18px;
            margin-bottom: 18px;
            color: #ccc;
        }

        #portada h2 {
            margin-top: 20px;
            color: #22ff88;
        }

        #portada ul {
            list-style: none;
            padding: 0;
        }

        #portada ul li {
            margin: 6px 0;
        }

        #portada .equipo {
            color: #ddd;
            line-height: 1.6;
        }

        #startBtn {
            margin-top: 28px;
            padding: 12px 32px;
            font-size: 18px;
            border: none;
            background: #22ff88;
            color: #000;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s ease;
            font-weight: bold;
        }

        #startBtn:hover {
            background: #44ffaa;
        }

        /* Estilos generales */
        body { 
            margin:0; 
            background:#000; 
            color:#fff; 
            font-family: Arial, sans-serif; 
            overflow:hidden; 
        }
        
        #info { 
            position:absolute; 
            top:8px; 
            left:8px; 
            z-index:10; 
            background:rgba(0,0,0,0.4); 
            padding:8px; 
            border-radius:6px; 
            font-size: 14px; 
        }
        
        #hud { 
            position: absolute; 
            right: 12px; 
            top: 12px; 
            z-index:10; 
            background: rgba(0,0,0,0.5); 
            padding:10px; 
            border-radius:6px; 
            text-align:right; 
            min-width:140px; 
        }
        
        #message { 
            position: absolute; 
            left:50%; 
            top:45%; 
            transform:translateX(-50%); 
            z-index:12; 
            pointer-events:none; 
            font-size:28px; 
            background:rgba(0,0,0,0.6); 
            padding:12px 20px; 
            border-radius:8px; 
            display:none; 
            white-space: pre-wrap;
            text-align: center;
        }
        
        canvas { display:block; }
        #stats-container { position: absolute; top: 0; left: 0; z-index: 100; }
        
        /* Estilos para VR */
        #vr-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #22ff88;
            z-index: 100;
        }
        
        #vr-info h3 {
            margin-top: 0;
            color: #22ff88;
        }
        
        #vr-info ul {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        
        #vr-info li {
            margin: 5px 0;
        }
        
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Audio -->
    <audio id="shootSound" src="assets/Disparo.mp3"></audio>
    <audio id="enemyDeathSound" src="assets/Explosion.mp3"></audio>
    <audio id="backgroundMusic" loop>
        <source src="assets/musica.mp3" type="audio/mpeg">
    </audio>

    <!-- PORTADA INICIAL -->
    <div id="portada">
        <div id="portada-content">
            <h1>Alienrinto VR</h1>
            <p class="sub">Laberinto Alienígena – Experiencia VR para Meta Quest 3</p>

            <h2>Instrucciones VR</h2>
            <ul>
                <li><strong>Joystick izquierdo</strong> - Movimiento</li>
                <li><strong>Gatillo derecho</strong> - Disparar</li>
                <li><strong>Botón A/X</strong> - Saltar</li>
                <li><strong>Botón de menú</strong> - Pausa/Salir VR</li>
                <li>Llega al portal sin que los aliens te maten</li>
            </ul>

            <h2>Integrantes del Equipo</h2>
            <p class="equipo">
                23200860 – Márquez Zempoalteca Judith<br>
                23200823 – Cruz Monter Sergio Eloy<br>
                23200904 – Veloz Pérez Mariana
            </p>

            <button id="startBtn">Iniciar Experiencia VR</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div><strong>Vida:</strong> <span id="life">100</span></div>
        <div><strong>Enemigos:</strong> <span id="enemiesCount">0</span></div>
        <div style="font-size:12px; margin-top:6px;">Objetivo: llegar al portal verde</div>
    </div>

    <div id="message"></div>

    <!-- Información VR -->
    <div id="vr-info" style="display: none;">
        <h3>Controles Quest 3</h3>
        <ul>
            <li><strong>Joystick:</strong> Moverse</li>
            <li><strong>Gatillo derecho:</strong> Disparar</li>
            <li><strong>Botón A/X:</strong> Saltar</li>
        </ul>
    </div>

    <div id="stats-container"></div>

    <script type="module">
        // ---------- Importaciones ----------
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // -------------------------------------------------------------------
        // ---------- CONFIGURACIÓN ----------
        // -------------------------------------------------------------------
        const CONFIG = {
            // Jugador VR
            GRAVITY: -30,
            PLAYER_SPEED: 80,
            PLAYER_JUMP_FORCE: 12,
            PLAYER_HEIGHT: 18,
            PLAYER_WIDTH: 8,
            PLAYER_DAMPING: 0.9,
            PLAYER_START_LIFE: 100,
            
            // Laberinto
            MAZE_COLS: 11,
            MAZE_ROWS: 11,
            CELL_SIZE: 80,
            WALL_HEIGHT: 36,
            WALL_THICKNESS: 8,
            
            // Enemigos
            ENEMY_COUNT: 8,
            ENEMY_HEALTH: 50,
            ENEMY_SPEED_MIN: 0.8,
            ENEMY_SPEED_MAX: 1.6,
            ENEMY_SIGHT_RANGE: 400,
            ENEMY_ATTACK_RANGE: 15,
            ENEMY_ATTACK_DAMAGE: 8,
            ENEMY_ATTACK_COOLDOWN: 1000,
            
            // Disparo
            SHOOT_DAMAGE: 30,
            SHOOT_RANGE: 50,
            
            // Archivos
            HDR_PATH: 'models/rgbe/fondo.hdr',
            FLOOR_TEX: 'models/rgbe/piso.jpg',
            WALL_TEX: 'models/rgbe/paredes.jpg',
        };

        // -------------------------------------------------------------------
        // ---------- Variables Globales ----------
        // -------------------------------------------------------------------
        let camera, scene, renderer, stats, clock;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let playerLife = CONFIG.PLAYER_START_LIFE;
        
        const physicsObjects = [];
        const enemies = [];
        const playerVelocity = new THREE.Vector3();
        let playerOnGround = false;
        const playerCollider = new THREE.Box3();
        
        // Elementos DOM
        const lifeEl = document.getElementById('life');
        const enemiesCountEl = document.getElementById('enemiesCount');
        const messageEl = document.getElementById('message');
        const vrInfoEl = document.getElementById('vr-info');
        const statsContainer = document.getElementById('stats-container');
        
        // Variables para modelos
        let playerModel, mixer;
        let wallMaterial;
        const raycaster = new THREE.Raycaster();

        // -------------------------------------------------------------------
        // ---------- Funciones Principales ----------
        // -------------------------------------------------------------------
        
        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xcccccc, 400, 1300);
            
            // Cámara
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // Renderizador con XR
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Botón VR
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Stats
            stats = new Stats();
            statsContainer.appendChild(stats.dom);
            
            // Cargar texturas
            const texLoader = new THREE.TextureLoader();
            const wallMap = texLoader.load(CONFIG.WALL_TEX);
            wallMap.wrapS = wallMap.wrapT = THREE.RepeatWrapping;
            wallMap.repeat.set(1, 1);
            
            wallMaterial = new THREE.MeshStandardMaterial({
                map: wallMap,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Cargar modelo del jugador
            const fbxLoader = new FBXLoader();
            fbxLoader.load('models/fbx/Jab Cross.fbx', (fbxScene) => {
                playerModel = fbxScene;
                const modelHeight = 150;
                const targetScale = CONFIG.PLAYER_HEIGHT / modelHeight;
                playerModel.scale.set(targetScale, targetScale, targetScale);
                
                playerModel.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = false;
                    }
                });
                
                scene.add(playerModel);
                
                // Crear mixer para animaciones
                mixer = new THREE.AnimationMixer(playerModel);
                
                // Cargar animaciones adicionales
                const animLoader = new FBXLoader();
                const animations = [
                    ['Running', 'models/fbx/Running.fbx'],
                    ['Jump', 'models/fbx/Jump.fbx'],
                    ['Walking', 'models/fbx/Walking.fbx']
                ];
                
                animations.forEach(([name, path]) => {
                    animLoader.load(path, (animFbx) => {
                        if (animFbx.animations.length > 0) {
                            const clip = animFbx.animations[0];
                            const action = mixer.clipAction(clip);
                            action.name = name;
                        }
                    });
                });
                
            }, undefined, err => console.warn('Error cargando modelo:', err));
            
            // Configurar controladores VR
            setupVRControllers();
            
            // Luces
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(100, 300, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);
            
            // Piso
            const floorMap = texLoader.load(CONFIG.FLOOR_TEX);
            floorMap.wrapS = floorMap.wrapT = THREE.RepeatWrapping;
            floorMap.repeat.set(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({ map: floorMap, roughness: 0.9 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Cielo HDR
            new RGBELoader().load(CONFIG.HDR_PATH, tex => {
                tex.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = tex;
                scene.background = tex;
            });
            
            // Generar nivel
            generateMaze(CONFIG.MAZE_ROWS, CONFIG.MAZE_COLS, CONFIG.CELL_SIZE);
            spawnEnemiesInMaze(CONFIG.ENEMY_COUNT);
            createGoalAtEnd();
            
            // Posicionar jugador
            const maze = scene.userData.maze;
            if (maze) {
                camera.position.set(
                    maze.startX + CONFIG.CELL_SIZE / 2,
                    CONFIG.PLAYER_HEIGHT * 0.8,
                    maze.startZ + CONFIG.CELL_SIZE / 2
                );
            }
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyF') handleShoot();
                if (e.code === 'Space' && playerOnGround) {
                    playerVelocity.y = CONFIG.PLAYER_JUMP_FORCE;
                    playerOnGround = false;
                }
            });
            
            // Iniciar música
            const bgMusic = document.getElementById('backgroundMusic');
            bgMusic.volume = 0.3;
            
            // Botón de inicio
            document.getElementById('startBtn').addEventListener('click', () => {
                document.getElementById('portada').style.opacity = "0";
                setTimeout(() => {
                    document.getElementById('portada').style.display = "none";
                    vrInfoEl.style.display = "block";
                    bgMusic.play().catch(e => console.log("Audio necesita interacción del usuario"));
                }, 500);
            });
        }
        
        function setupVRControllers() {
            const controllerModelFactory = new XRControllerModelFactory();
            
            // Controlador 1 (izquierdo)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            // Controlador 2 (derecho)
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', () => handleShoot());
            controller2.addEventListener('squeezestart', () => {
                if (playerOnGround) {
                    playerVelocity.y = CONFIG.PLAYER_JUMP_FORCE;
                    playerOnGround = false;
                }
            });
            scene.add(controller2);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
            
            // Rayo para el controlador derecho (indicador de disparo)
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00 }));
            line.scale.z = 10;
            controller2.add(line);
        }
        
        function onSelectStart() {
            // Para agarre o interacción con la mano izquierda
        }
        
        function onSelectEnd() {
            // Para soltar objetos con la mano izquierda
        }
        
        function handleShoot() {
            if (!renderer.xr.isPresenting) return;
            
            // Disparar desde el controlador derecho
            const origin = controller2.position.clone();
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(controller2.quaternion);
            
            raycaster.set(origin, dir);
            raycaster.far = CONFIG.SHOOT_RANGE;
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object.userData && hit.object.userData.alive) {
                    applyDamageToEnemy(hit.object, CONFIG.SHOOT_DAMAGE);
                }
                
                // Efecto visual de disparo
                const shootEffect = new THREE.PointLight(0xffff00, 2, 20);
                shootEffect.position.copy(origin);
                scene.add(shootEffect);
                
                setTimeout(() => scene.remove(shootEffect), 100);
                
                // Sonido
                const shootSound = document.getElementById('shootSound');
                if (shootSound) {
                    shootSound.currentTime = 0;
                    shootSound.play();
                }
            }
        }
        
        function updateVRMovement() {
            if (!renderer.xr.isPresenting || !controller1) return;
            
            const session = renderer.xr.getSession();
            if (!session) return;
            
            // Obtener input del joystick
            for (const inputSource of session.inputSources) {
                if (inputSource.handedness === 'left') {
                    const gamepad = inputSource.gamepad;
                    if (gamepad) {
                        // Joystick izquierdo para movimiento
                        const xAxis = gamepad.axes[2] || 0;
                        const yAxis = gamepad.axes[3] || 0;
                        
                        if (Math.abs(xAxis) > 0.1 || Math.abs(yAxis) > 0.1) {
                            // Dirección basada en la cámara
                            const forward = new THREE.Vector3();
                            const right = new THREE.Vector3();
                            
                            camera.getWorldDirection(forward);
                            forward.y = 0;
                            forward.normalize();
                            
                            right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();
                            
                            // Movimiento
                            playerVelocity.x = -right.x * xAxis * CONFIG.PLAYER_SPEED;
                            playerVelocity.z = -right.z * xAxis * CONFIG.PLAYER_SPEED;
                            
                            playerVelocity.x += forward.x * yAxis * CONFIG.PLAYER_SPEED;
                            playerVelocity.z += forward.z * yAxis * CONFIG.PLAYER_SPEED;
                        } else {
                            // Frenar si no hay input
                            playerVelocity.x *= CONFIG.PLAYER_DAMPING;
                            playerVelocity.z *= CONFIG.PLAYER_DAMPING;
                        }
                    }
                }
            }
        }
        
        function updatePhysics(dt) {
            // Gravedad
            playerVelocity.y += CONFIG.GRAVITY * dt;
            
            // Colisiones
            const delta = playerVelocity.clone().multiplyScalar(dt);
            const playerHalfHeight = CONFIG.PLAYER_HEIGHT / 2;
            
            playerCollider.setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT, CONFIG.PLAYER_WIDTH)
            );
            
            // Colisión eje Y
            const futureYCollider = playerCollider.clone().translate(new THREE.Vector3(0, delta.y, 0));
            playerOnGround = false;
            
            for (const obj of physicsObjects) {
                if (futureYCollider.intersectsBox(obj.boundingBox)) {
                    if (playerVelocity.y < 0) {
                        playerOnGround = true;
                        camera.position.y = obj.boundingBox.max.y + playerHalfHeight;
                    }
                    playerVelocity.y = 0;
                    delta.y = 0;
                    break;
                }
            }
            
            // Colisión eje X
            const futureXCollider = playerCollider.clone().translate(new THREE.Vector3(delta.x, 0, 0));
            for (const obj of physicsObjects) {
                if (futureXCollider.intersectsBox(obj.boundingBox)) {
                    playerVelocity.x = 0;
                    delta.x = 0;
                    break;
                }
            }
            
            // Colisión eje Z
            const futureZCollider = playerCollider.clone().translate(new THREE.Vector3(0, 0, delta.z));
            for (const obj of physicsObjects) {
                if (futureZCollider.intersectsBox(obj.boundingBox)) {
                    playerVelocity.z = 0;
                    delta.z = 0;
                    break;
                }
            }
            
            // Aplicar movimiento
            camera.position.add(delta);
            
            // Limitar altura mínima
            if (camera.position.y < playerHalfHeight) {
                playerVelocity.y = 0;
                camera.position.y = playerHalfHeight;
                playerOnGround = true;
            }
            
            // IA de enemigos
            const playerPos = camera.position;
            for (const enemy of enemies) {
                if (!enemy.userData || !enemy.userData.alive) continue;
                
                const toPlayer = new THREE.Vector3().subVectors(playerPos, enemy.position);
                const dist = toPlayer.length();
                
                if (dist < CONFIG.ENEMY_SIGHT_RANGE) {
                    toPlayer.normalize();
                    toPlayer.y = 0;
                    enemy.position.addScaledVector(toPlayer, enemy.userData.speed * dt * 60);
                    
                    // Actualizar bounding box
                    const enemyPhysObj = physicsObjects.find(p => p.mesh === enemy);
                    if (enemyPhysObj) enemyPhysObj.boundingBox.setFromObject(enemy);
                    
                    // Atacar
                    if (dist < CONFIG.ENEMY_ATTACK_RANGE) {
                        if (!enemy.userData._lastAttack || (performance.now() - enemy.userData._lastAttack) > CONFIG.ENEMY_ATTACK_COOLDOWN) {
                            enemy.userData._lastAttack = performance.now();
                            playerLife -= CONFIG.ENEMY_ATTACK_DAMAGE;
                            if (playerLife < 0) playerLife = 0;
                            lifeEl.textContent = playerLife;
                            if (playerLife <= 0) onPlayerDead();
                        }
                    }
                }
            }
            
            // Chequear victoria
            const goal = scene.userData.goal;
            if (goal && playerLife > 0) {
                const distGoal = camera.position.distanceTo(goal.position);
                if (distGoal < 50) {
                    showMessage('¡GANASTE!\n<span style="font-size: 18px">Llegaste al portal</span>', 7000);
                    playerLife = -1;
                }
            }
        }
        
        function applyDamageToEnemy(enemy, amount) {
            if (!enemy.userData) return;
            enemy.userData.health -= amount;
            
            enemy.material.emissive = new THREE.Color(0xff0000);
            setTimeout(() => { 
                if (enemy.material) enemy.material.emissive = new THREE.Color(0x000000);
            }, 120);
            
            if (enemy.userData.health <= 0 && enemy.userData.alive) {
                enemy.userData.alive = false;
                
                const deathSound = document.getElementById('enemyDeathSound');
                if (deathSound) {
                    deathSound.currentTime = 0;
                    deathSound.play();
                }
                
                enemy.rotation.z = Math.PI / 2;
                enemy.material.color.set(0x333333);
                
                const idx = physicsObjects.findIndex(p => p.mesh === enemy);
                if (idx >= 0) physicsObjects.splice(idx, 1);
                
                setTimeout(() => { 
                    scene.remove(enemy); 
                    updateEnemiesHUD(); 
                }, 1200);
            }
            
            updateEnemiesHUD();
        }
        
        function generateMaze(rows, cols, cellSize) {
            // Generación del laberinto (mismo código anterior)
            const grid = [];
            for(let r=0;r<rows;r++){ grid[r] = []; for(let c=0;c<cols;c++){ grid[r][c] = { r, c, visited:false, walls: [true,true,true,true] }; }}
            const stack = []; let current = grid[0][0]; current.visited = true;
            function neighbors(cell){ const n = []; const {r,c} = cell; if(r>0 && !grid[r-1][c].visited) n.push(grid[r-1][c]); if(c<cols-1 && !grid[r][c+1].visited) n.push(grid[r][c+1]); if(r<rows-1 && !grid[r+1][c].visited) n.push(grid[r+1][c]); if(c>0 && !grid[r][c-1].visited) n.push(grid[r][c-1]); return n; }
            while(true){ const n = neighbors(current); if(n.length>0){ const next = n[Math.floor(Math.random()*n.length)]; stack.push(current); const dr = next.r - current.r; const dc = next.c - current.c; if(dr === -1){ current.walls[0] = false; next.walls[2] = false; } if(dc === 1){ current.walls[1] = false; next.walls[3] = false; } if(dr === 1){ current.walls[2] = false; next.walls[0] = false; } if(dc === -1){ current.walls[3] = false; next.walls[1] = false; } current = next; current.visited = true; } else if(stack.length>0){ current = stack.pop(); } else break; }
            
            const startX = -(cols * cellSize) / 2;
            const startZ = -(rows * cellSize) / 2;
            const wallHeightHalf = CONFIG.WALL_HEIGHT / 2;
            
            const wallGeo = new THREE.BoxGeometry(
                cellSize + CONFIG.WALL_THICKNESS, 
                CONFIG.WALL_HEIGHT, 
                CONFIG.WALL_THICKNESS
            );
            
            const createWall = (posX, posZ, rotY) => {
                const wall = new THREE.Mesh(wallGeo, wallMaterial);
                wall.position.set(posX, wallHeightHalf, posZ);
                wall.rotation.y = rotY;
                wall.receiveShadow = true;
                wall.castShadow = true;
                scene.add(wall);
                
                wall.updateMatrixWorld();
                const wallBox = new THREE.Box3().setFromObject(wall);
                physicsObjects.push({ mesh: wall, boundingBox: wallBox, static: true });
            };
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = grid[r][c];
                    const cx = startX + c * cellSize + cellSize / 2;
                    const cz = startZ + r * cellSize + cellSize / 2;
                    
                    if (cell.walls[0]) createWall(cx, cz - cellSize / 2, 0);
                    if (cell.walls[1]) createWall(cx + cellSize / 2, cz, Math.PI / 2);
                    if (cell.walls[2]) createWall(cx, cz + cellSize / 2, 0);
                    if (cell.walls[3]) createWall(cx - cellSize / 2, cz, Math.PI / 2);
                }
            }
            
            scene.userData.maze = { grid, startX, startZ, rows, cols, cellSize };
        }
        
        function spawnEnemiesInMaze(count) {
            const maze = scene.userData.maze;
            if (!maze) return;
            
            const { startX, startZ, rows, cols, cellSize } = maze;
            const enemyGeo = new THREE.BoxGeometry(15, 15, 15);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xdd4444, roughness: 0.8 });
            
            let placed = 0;
            while (placed < count) {
                const r = 1 + Math.floor(Math.random() * (rows - 2));
                const c = 1 + Math.floor(Math.random() * (cols - 2));
                const x = startX + c * cellSize + cellSize / 2;
                const z = startZ + r * cellSize + cellSize / 2;
                
                if (Math.hypot(x - (startX + cellSize / 2), z - (startZ + cellSize / 2)) < cellSize) continue;
                
                const enemy = new THREE.Mesh(enemyGeo, enemyMat);
                enemy.position.set(x, 7.5, z);
                enemy.castShadow = true;
                enemy.receiveShadow = true;
                
                enemy.userData = { 
                    health: CONFIG.ENEMY_HEALTH, 
                    alive: true, 
                    speed: CONFIG.ENEMY_SPEED_MIN + Math.random() * (CONFIG.ENEMY_SPEED_MAX - CONFIG.ENEMY_SPEED_MIN) 
                };
                
                scene.add(enemy);
                enemy.updateMatrixWorld();
                const enemyBox = new THREE.Box3().setFromObject(enemy);
                
                enemies.push(enemy);
                physicsObjects.push({ mesh: enemy, boundingBox: enemyBox, mass: 50 });
                placed++;
            }
            
            updateEnemiesHUD();
        }
        
        function createGoalAtEnd() {
            const maze = scene.userData.maze;
            if (!maze) return;
            
            const { startX, startZ, rows, cols, cellSize } = maze;
            const gx = startX + (cols-1) * cellSize + cellSize / 2;
            const gz = startZ + (rows-1) * cellSize + cellSize / 2;
            
            const portalGeo = new THREE.TorusGeometry(30, 6, 16, 100);
            const portalMat = new THREE.MeshStandardMaterial({ 
                color: 0x22ff88, 
                emissive: 0x22ff88, 
                emissiveIntensity: 0.8 
            });
            
            const portal = new THREE.Mesh(portalGeo, portalMat);
            portal.rotation.x = Math.PI / 2;
            portal.position.set(gx, 45, gz);
            portal.castShadow = true;
            scene.add(portal);
            
            // Añadir luz al portal
            const portalLight = new THREE.PointLight(0x22ff88, 1, 100);
            portalLight.position.set(gx, 60, gz);
            scene.add(portalLight);
            
            scene.userData.goal = { mesh: portal, position: new THREE.Vector3(gx, 0, gz) };
        }
        
        function updateEnemiesHUD() {
            const alive = enemies.filter(e => e.userData && e.userData.alive).length;
            enemiesCountEl.textContent = alive;
        }
        
        function showMessage(text, ms = 3000) {
            messageEl.style.display = 'block';
            messageEl.innerHTML = text;
            if (ms > 0) setTimeout(() => { messageEl.style.display = 'none'; }, ms);
        }
        
        function onPlayerDead() {
            showMessage('- GAME OVER -\n<span style="font-size: 18px">Recarga la página para volver a jugar</span>', 10000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // -------------------------------------------------------------------
        // ---------- Loop de Animación ----------
        // -------------------------------------------------------------------
        function animate() {
            const dt = clock.getDelta();
            
            if (mixer) mixer.update(dt);
            
            if (playerLife > 0) {
                updateVRMovement();
                updatePhysics(dt);
            }
            
            renderer.render(scene, camera);
            stats.update();
        }
        
        // Inicializar
        init();
        renderer.setAnimationLoop(animate);
    </script>
</body>
</html>
