<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mundo Virtual - Primera Persona con Joysticks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            margin-bottom: 10px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        
        .subtitle {
            margin-bottom: 30px;
            color: #a0e7ff;
        }
        
        #scene-container {
            width: 100%;
            height: 70vh;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 2px solid #00d4ff;
            margin-bottom: 20px;
        }
        
        #renderer {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 0 auto 30px;
            padding: 0 20px;
        }
        
        .joystick-container {
            width: 200px;
            height: 200px;
            position: relative;
        }
        
        .joystick-label {
            margin-bottom: 10px;
            color: #00d4ff;
            font-weight: bold;
        }
        
        .joystick-base {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #00d4ff;
            position: relative;
            margin: 0 auto;
            box-shadow: inset 0 0 15px rgba(0, 212, 255, 0.3);
        }
        
        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #00d4ff 0%, #008cff 100%);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.7);
            transition: transform 0.1s;
        }
        
        .joystick-handle.active {
            background: radial-gradient(circle, #ff416c 0%, #ff4b2b 100%);
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.9);
        }
        
        .controls-info {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-width: 800px;
            border: 1px solid #00d4ff;
        }
        
        .controls-info h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .key {
            display: inline-block;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            border-radius: 5px;
            padding: 5px 10px;
            margin-right: 10px;
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }
        
        #mobile-warning {
            display: none;
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid #ff6464;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-width: 800px;
        }
        
        #mobile-warning h3 {
            color: #ff6464;
            margin-bottom: 10px;
        }
        
        #status {
            margin-top: 15px;
            font-style: italic;
            color: #a0e7ff;
        }
        
        @media (max-width: 768px) {
            .controls-container {
                flex-direction: column;
                align-items: center;
            }
            
            .joystick-container {
                margin-bottom: 30px;
            }
            
            #mobile-warning {
                display: block;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <div id="container">
        <h1>MUNDO VIRTUAL EN PRIMERA PERSONA</h1>
        <p class="subtitle">Control mediante joysticks - Vista en primera persona</p>
        
        <div id="scene-container">
            <canvas id="renderer"></canvas>
        </div>
        
        <div class="controls-container">
            <div class="joystick-container">
                <div class="joystick-label">Movimiento</div>
                <div class="joystick-base" id="movement-joystick-base">
                    <div class="joystick-handle" id="movement-joystick-handle"></div>
                </div>
            </div>
            
            <div class="joystick-container">
                <div class="joystick-label">Rotación/Vista</div>
                <div class="joystick-base" id="rotation-joystick-base">
                    <div class="joystick-handle" id="rotation-joystick-handle"></div>
                </div>
            </div>
        </div>
        
        <div id="mobile-warning">
            <h3>Nota para dispositivos móviles:</h3>
            <p>Para una mejor experiencia, se recomienda usar un dispositivo con pantalla más grande o un computador de escritorio. En móviles, puedes tocar y arrastrar los joysticks para moverte.</p>
        </div>
        
        <div class="controls-info">
            <h3>Controles Disponibles</h3>
            <div class="controls-grid">
                <div class="control-item">
                    <span class="key">Joystick Izq</span>
                    <span>Movimiento adelante/atrás y lateral</span>
                </div>
                <div class="control-item">
                    <span class="key">Joystick Der</span>
                    <span>Rotar vista y mirar alrededor</span>
                </div>
                <div class="control-item">
                    <span class="key">Click</span>
                    <span>Bloquear/desbloquear cursor</span>
                </div>
                <div class="control-item">
                    <span class="key">ESPACIO</span>
                    <span>Saltar</span>
                </div>
            </div>
            <div id="status">Estado: Esperando interacción...</div>
        </div>
    </div>

    <script>
        // main.js
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

// -------------------------------------------------------------------
// ---------- CONFIGURACIÓN ----------
// -------------------------------------------------------------------
const CONFIG = {
    // Laberinto
    MAZE_COLS: 11,
    MAZE_ROWS: 11,
    CELL_SIZE: 80,
    WALL_HEIGHT: 36,
    WALL_THICKNESS: 8,
    
    // Enemigos
    ENEMY_COUNT: 8,
    ENEMY_HEALTH: 50,
    ENEMY_SPEED_MIN: 0.8,
    ENEMY_SPEED_MAX: 1.6,
    ENEMY_SIGHT_RANGE: 400,
    ENEMY_ATTACK_RANGE: 15,
    ENEMY_ATTACK_DAMAGE: 8,
    
    // Texturas
    WALL_TEX: 'models/rgbe/paredes.jpg',
    FLOOR_TEX: 'models/rgbe/piso.jpg',
    
    // VR
    PLAYER_RADIUS: 0.35,
    VR_WALK_SPEED: 5.5,
    VR_STRAFE_SPEED: 4.8,
    
    // Otros
    FOG_DENSITY: 0.028,
    ARC_STEPS: 40,
    ARC_SPEED: 7.5,
    ARC_GRAVITY: 9.8,
    MAX_SLOPE_DEG: 45
};

/** ========= DOM / UI ========= */
const hudTotal = document.getElementById('totalPumpkins');
const hudHit   = document.getElementById('hitPumpkins');

/** ========= RENDERER / SCENES / CAMERA ========= */
const canvas = document.getElementById('scene');
const ambientEl = document.getElementById('ambient');

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
renderer.autoClear = true;

// Escena principal
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06101a);
scene.fog = new THREE.FogExp2(0x06101a, CONFIG.FOG_DENSITY);

// Escena de fondo (cielo/estrellas/luna)
const bgScene = new THREE.Scene();
const bgCam = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 5000);

// Cámara del jugador
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 500);
const player = new THREE.Group();
player.add(camera);
scene.add(player);

// Variables globales para el juego
const physicsObjects = [];
const enemies = [];
const pumpkinColliders = []; // Mantenemos para compatibilidad con UI existente

/** ========= IBL / HDRI ========= */
const pmremGen = new THREE.PMREMGenerator(renderer);
pmremGen.compileEquirectangularShader();
async function setHDRI(url) {
  const hdr = await new Promise((res, rej) => new RGBELoader().load(url, (t)=>res(t), undefined, rej));
  const env = pmremGen.fromEquirectangular(hdr).texture;
  scene.environment = env;
  hdr.dispose(); pmremGen.dispose();
}
setHDRI('assets/hdr/moonless_golf_1k.hdr').catch(()=> console.warn('Sin HDRI'));

/** ========= LUCES ========= */
const hemiLight = new THREE.HemisphereLight(0x8fb2ff, 0x0a0c10, 0.35);
scene.add(hemiLight);

// Luz direccional principal
const mainLight = new THREE.DirectionalLight(0xcfe2ff, 1.25);
mainLight.castShadow = true;
mainLight.shadow.mapSize.set(2048, 2048);
mainLight.shadow.camera.near = 0.5;
mainLight.shadow.camera.far = 1000;
mainLight.position.set(50, 100, 50);
scene.add(mainLight);

/** ========= CIELO / ESTRELLAS en bgScene ========= */
const skyGeo = new THREE.SphereGeometry(2000, 48, 24);
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  depthWrite: false,
  depthTest: false,
  fog: false,
  uniforms: {
    topColor:    { value: new THREE.Color(0x0a1f35) },
    bottomColor: { value: new THREE.Color(0x050910) }
  },
  vertexShader: /* glsl */`
    varying vec3 vDir;
    void main(){
      vDir = normalize(position);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: /* glsl */`
    varying vec3 vDir;
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    void main(){
      float t = smoothstep(-0.2, 0.8, vDir.y);
      vec3 col = mix(bottomColor, topColor, t);
      gl_FragColor = vec4(col, 1.0);
    }
  `
});
const skyMesh = new THREE.Mesh(skyGeo, skyMat);
skyMesh.renderOrder = -2;
skyMesh.frustumCulled = false;
bgScene.add(skyMesh);

// Estrellas
const starCount = 3500;
const starPositions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) {
  const r = 1400 + Math.random() * 400;
  const a = Math.random() * Math.PI * 2;
  const b = Math.acos(2 * Math.random() - 1);
  starPositions[i*3+0] = r * Math.sin(b) * Math.cos(a);
  starPositions[i*3+1] = r * Math.cos(b);
  starPositions[i*3+2] = r * Math.sin(b) * Math.sin(a);
}
const starGeo = new THREE.BufferGeometry();
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const starMat = new THREE.PointsMaterial({
  size: 2.2,
  sizeAttenuation: false,
  color: 0xffffff,
  fog: false,
  depthTest: false,
  transparent: true,
  opacity: 0.95
});
const starField = new THREE.Points(starGeo, starMat);
starField.renderOrder = -1;
starField.matrixAutoUpdate = false;
starField.frustumCulled = false;
bgScene.add(starField);

/** ========= AUDIO ========= */
const listener = new THREE.AudioListener();
camera.add(listener);
const audioLoader = new THREE.AudioLoader();

let windBuffer = null;
audioLoader.load('assets/audio/wind.mp3', (buf)=> windBuffer = buf);

let windSfx = null;
function startAmbientAudio(){
  const ctx = listener.context;
  if (ambientEl) {
    try {
      const srcNode = ctx.createMediaElementSource(ambientEl);
      srcNode.connect(listener.getInput());
      ambientEl.loop = true;
      ambientEl.volume = 0.4;
      ambientEl.play().catch(()=>{});
    } catch {}
  }
  if (windBuffer && !windSfx) {
    windSfx = new THREE.Audio(listener);
    windSfx.setBuffer(windBuffer);
    windSfx.setLoop(true);
    windSfx.setVolume(0.28);
    windSfx.play();
  }
}

// -------------------------------------------------------------------
// ---------- GENERACIÓN DEL LABERINTO ----------
// -------------------------------------------------------------------
function generateMaze(rows, cols, cellSize) {
    // 1. Crear grid para algoritmo de laberinto
    const grid = [];
    for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
            grid[r][c] = { 
                r, c, 
                visited: false, 
                walls: [true, true, true, true] // [norte, este, sur, oeste]
            };
        }
    }
    
    // 2. Algoritmo de laberinto (Depth-First Search)
    const stack = [];
    let current = grid[0][0];
    current.visited = true;
    
    // Función para obtener vecinos no visitados
    function getNeighbors(cell) {
        const n = [];
        const { r, c } = cell;
        
        if (r > 0 && !grid[r - 1][c].visited) n.push(grid[r - 1][c]); // Norte
        if (c < cols - 1 && !grid[r][c + 1].visited) n.push(grid[r][c + 1]); // Este
        if (r < rows - 1 && !grid[r + 1][c].visited) n.push(grid[r + 1][c]); // Sur
        if (c > 0 && !grid[r][c - 1].visited) n.push(grid[r][c - 1]); // Oeste
        
        return n;
    }
    
    // Generar laberinto
    while (true) {
        const neighbors = getNeighbors(current);
        
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);
            
            // Eliminar pared entre celda actual y siguiente
            const dr = next.r - current.r;
            const dc = next.c - current.c;
            
            if (dr === -1) { // Norte
                current.walls[0] = false;
                next.walls[2] = false;
            } else if (dc === 1) { // Este
                current.walls[1] = false;
                next.walls[3] = false;
            } else if (dr === 1) { // Sur
                current.walls[2] = false;
                next.walls[0] = false;
            } else if (dc === -1) { // Oeste
                current.walls[3] = false;
                next.walls[1] = false;
            }
            
            current = next;
            current.visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }
    
    // 3. Posición inicial del laberinto
    const startX = -(cols * cellSize) / 2;
    const startZ = -(rows * cellSize) / 2;
    const wallHeightHalf = CONFIG.WALL_HEIGHT / 2;
    
    // 4. Geometría de las paredes
    const wallGeo = new THREE.BoxGeometry(
        cellSize + CONFIG.WALL_THICKNESS, 
        CONFIG.WALL_HEIGHT, 
        CONFIG.WALL_THICKNESS
    );
    
    // 5. Cargar textura de paredes
    const texLoader = new THREE.TextureLoader();
    const wallMap = texLoader.load(CONFIG.WALL_TEX);
    wallMap.wrapS = wallMap.wrapT = THREE.RepeatWrapping;
    
    const wallMaterial = new THREE.MeshStandardMaterial({
        map: wallMap,
        roughness: 0.8,
        metalness: 0.2
    });
    
    // 6. Función para crear una pared individual
    function createWall(posX, posZ, rotY) {
        const wall = new THREE.Mesh(wallGeo, wallMaterial);
        wall.position.set(posX, wallHeightHalf, posZ);
        wall.rotation.y = rotY;
        wall.receiveShadow = true;
        wall.castShadow = true;
        scene.add(wall);
        
        // Configurar repetición de textura
        if (wall.material.map) {
            wall.material.map.repeat.set(
                1, 
                CONFIG.WALL_HEIGHT / (CONFIG.WALL_THICKNESS * 2)
            );
        }
        
        // Agregar a colisiones
        wall.updateMatrixWorld();
        const wallBox = new THREE.Box3().setFromObject(wall);
        physicsObjects.push({ 
            mesh: wall, 
            boundingBox: wallBox, 
            static: true 
        });
    }
    
    // 7. Crear todas las paredes del laberinto
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = grid[r][c];
            const cx = startX + c * cellSize + cellSize / 2;
            const cz = startZ + r * cellSize + cellSize / 2;
            
            // Crear paredes según las banderas
            if (cell.walls[0]) createWall(cx, cz - cellSize / 2, 0); // Norte
            if (cell.walls[1]) createWall(cx + cellSize / 2, cz, Math.PI / 2); // Este
            if (cell.walls[2]) createWall(cx, cz + cellSize / 2, 0); // Sur
            if (cell.walls[3]) createWall(cx - cellSize / 2, cz, Math.PI / 2); // Oeste
        }
    }
    
    // 8. Guardar información del laberinto
    scene.userData.maze = { 
        grid, 
        startX, 
        startZ, 
        rows, 
        cols, 
        cellSize 
    };
    
    console.log(`Laberinto generado: ${rows}x${cols} celdas`);
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DE ENEMIGOS ----------
// -------------------------------------------------------------------
function spawnEnemiesInMaze(count) {
    const maze = scene.userData.maze;
    if (!maze) {
        console.error("No hay laberinto generado");
        return;
    }
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    // Geometría y material del enemigo
    const enemyGeo = new THREE.BoxGeometry(15, 15, 15);
    const enemyMat = new THREE.MeshStandardMaterial({ 
        color: 0xdd4444, 
        roughness: 0.8,
        emissive: 0x220000,
        emissiveIntensity: 0.1
    });
    
    let placed = 0;
    const maxAttempts = count * 10;
    let attempts = 0;
    
    // Colocar enemigos en posiciones aleatorias del laberinto
    while (placed < count && attempts < maxAttempts) {
        attempts++;
        
        // Escoger celda aleatoria (evitar bordes)
        const r = 1 + Math.floor(Math.random() * (rows - 2));
        const c = 1 + Math.floor(Math.random() * (cols - 2));
        
        const x = startX + c * cellSize + cellSize / 2;
        const z = startZ + r * cellSize + cellSize / 2;
        
        // No colocar cerca del inicio
        const startCellX = startX + cellSize / 2;
        const startCellZ = startZ + cellSize / 2;
        const distanceToStart = Math.hypot(x - startCellX, z - startCellZ);
        
        if (distanceToStart < cellSize * 2) continue;
        
        // Verificar que no haya otro enemigo muy cerca
        let tooClose = false;
        for (const enemy of enemies) {
            if (enemy.position.distanceTo(new THREE.Vector3(x, 7.5, z)) < cellSize) {
                tooClose = true;
                break;
            }
        }
        
        if (tooClose) continue;
        
        // Crear enemigo
        const enemy = new THREE.Mesh(enemyGeo, enemyMat);
        enemy.position.set(x, 7.5, z);
        enemy.castShadow = true;
        enemy.receiveShadow = true;
        
        // Datos del enemigo
        enemy.userData = { 
            health: CONFIG.ENEMY_HEALTH, 
            alive: true, 
            speed: CONFIG.ENEMY_SPEED_MIN + Math.random() * (CONFIG.ENEMY_SPEED_MAX - CONFIG.ENEMY_SPEED_MIN),
            lastAttack: 0
        };
        
        scene.add(enemy);
        
        // Agregar a colisiones
        enemy.updateMatrixWorld();
        const enemyBox = new THREE.Box3().setFromObject(enemy);
        
        enemies.push(enemy);
        physicsObjects.push({ 
            mesh: enemy, 
            boundingBox: enemyBox, 
            mass: 50 
        });
        
        placed++;
    }
    
    console.log(`${placed} enemigos colocados en el laberinto`);
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PORTAL (OBJETIVO) ----------
// -------------------------------------------------------------------
function createGoalAtEnd() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    // Posición del portal (esquina opuesta al inicio)
    const goalX = startX + (cols - 1) * cellSize + cellSize / 2;
    const goalZ = startZ + (rows - 1) * cellSize + cellSize / 2;
    
    // Geometría del portal (toro animado)
    const portalGeo = new THREE.TorusGeometry(30, 6, 16, 100);
    const portalMat = new THREE.MeshStandardMaterial({ 
        color: 0x22ff88, 
        emissive: 0x22ff88, 
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9
    });
    
    const portal = new THREE.Mesh(portalGeo, portalMat);
    portal.rotation.x = Math.PI / 2;
    portal.position.set(goalX, 45, goalZ);
    portal.castShadow = true;
    scene.add(portal);
    
    // Efecto de partículas alrededor del portal
    createPortalParticles(goalX, goalZ);
    
    // Guardar referencia
    scene.userData.goal = { 
        mesh: portal, 
        position: new THREE.Vector3(goalX, 0, goalZ),
        radius: 30
    };
    
    console.log(`Portal creado en posición: (${goalX.toFixed(1)}, ${goalZ.toFixed(1)})`);
}

// -------------------------------------------------------------------
// ---------- EFECTO DE PARTÍCULAS DEL PORTAL ----------
// -------------------------------------------------------------------
function createPortalParticles(x, z) {
    const particleCount = 100;
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        const radius = 25 + Math.random() * 10;
        const angle = Math.random() * Math.PI * 2;
        const height = 20 + Math.random() * 50;
        
        positions[i * 3] = x + Math.cos(angle) * radius;
        positions[i * 3 + 1] = height;
        positions[i * 3 + 2] = z + Math.sin(angle) * radius;
        
        // Color verde para partículas
        colors[i * 3] = 0.2 + Math.random() * 0.3;     // R
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2; // G
        colors[i * 3 + 2] = 0.3 + Math.random() * 0.2; // B
    }
    
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMat = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.7
    });
    
    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);
    
    // Guardar para animación
    scene.userData.portalParticles = {
        mesh: particles,
        time: 0,
        positions: positions
    };
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PISO ----------
// -------------------------------------------------------------------
function createFloor() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { rows, cols, cellSize } = maze;
    
    // Calcular tamaño del piso (más grande que el laberinto)
    const floorWidth = cols * cellSize + cellSize * 2;
    const floorHeight = rows * cellSize + cellSize * 2;
    
    // Cargar textura del piso
    const texLoader = new THREE.TextureLoader();
    const floorMap = texLoader.load(CONFIG.FLOOR_TEX);
    floorMap.wrapS = floorMap.wrapT = THREE.RepeatWrapping;
    floorMap.repeat.set(rows * 0.5, cols * 0.5);
    
    const floorMat = new THREE.MeshStandardMaterial({ 
        map: floorMap, 
        roughness: 0.9,
        metalness: 0.1
    });
    
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(floorWidth, floorHeight),
        floorMat
    );
    
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    floor.receiveShadow = true;
    scene.add(floor);
    
    console.log(`Piso creado: ${floorWidth}x${floorHeight}`);
}

// -------------------------------------------------------------------
// ---------- INICIALIZACIÓN COMPLETA DEL ESCENARIO ----------
// -------------------------------------------------------------------
function createGameScene() {
    // 1. Generar laberinto
    generateMaze(CONFIG.MAZE_ROWS, CONFIG.MAZE_COLS, CONFIG.CELL_SIZE);
    
    // 2. Crear piso
    createFloor();
    
    // 3. Colocar enemigos
    spawnEnemiesInMaze(CONFIG.ENEMY_COUNT);
    
    // 4. Crear portal objetivo
    createGoalAtEnd();
    
    // 5. Posicionar al jugador en el inicio
    const maze = scene.userData.maze;
    if (maze) {
        const startPos = new THREE.Vector3(
            maze.startX + CONFIG.CELL_SIZE / 2,
            10,
            maze.startZ + CONFIG.CELL_SIZE / 2
        );
        
        player.position.copy(startPos);
        return startPos;
    }
    
    const defaultStart = new THREE.Vector3(0, 10, 0);
    player.position.copy(defaultStart);
    return defaultStart;
}

// -------------------------------------------------------------------
// ---------- ANIMACIÓN DE PARTÍCULAS DEL PORTAL ----------
// -------------------------------------------------------------------
function animatePortalParticles(deltaTime) {
    const portalParticles = scene.userData.portalParticles;
    if (!portalParticles) return;
    
    portalParticles.time += deltaTime;
    const positions = portalParticles.positions;
    const portalPos = scene.userData.goal.position;
    
    for (let i = 0; i < positions.length / 3; i++) {
        const idx = i * 3;
        const radius = 25 + Math.random() * 10;
        const angle = (portalParticles.time * 0.5 + i * 0.1) % (Math.PI * 2);
        const height = 20 + Math.sin(portalParticles.time + i) * 10;
        
        positions[idx] = portalPos.x + Math.cos(angle) * radius;
        positions[idx + 1] = height;
        positions[idx + 2] = portalPos.z + Math.sin(angle) * radius;
    }
    
    portalParticles.mesh.geometry.attributes.position.needsUpdate = true;
    portalParticles.mesh.rotation.y += deltaTime * 0.2;
    
    // Animar portal también
    if (scene.userData.goal) {
        scene.userData.goal.mesh.rotation.y += deltaTime * 0.5;
    }
}

/** ========= VR: CONTROLADORES + TELEPORT ========= */
const vrBtn = VRButton.createButton(renderer);
vrBtn.classList.add('vr-button');
document.body.appendChild(vrBtn);

const controllerLeft = renderer.xr.getController(0);
const controllerRight = renderer.xr.getController(1);
scene.add(controllerLeft, controllerRight);

const controllerModelFactory = new XRControllerModelFactory();
const grip0 = renderer.xr.getControllerGrip(0);
grip0.add(controllerModelFactory.createControllerModel(grip0)); scene.add(grip0);
const grip1 = renderer.xr.getControllerGrip(1);
grip1.add(controllerModelFactory.createControllerModel(grip1)); scene.add(grip1);

// Arco + marcador para teleport
const arcMatOK  = new THREE.LineBasicMaterial({ color: 0x7ad1ff, transparent:true, opacity:0.95 });
const arcMatBAD = new THREE.LineBasicMaterial({ color: 0xff5a5a, transparent:true, opacity:0.95 });
let arcMaterial = arcMatOK;
const arcGeo = new THREE.BufferGeometry().setFromPoints(new Array(CONFIG.ARC_STEPS).fill(0).map(()=>new THREE.Vector3()));
const arcLine = new THREE.Line(arcGeo, arcMaterial); arcLine.visible=false; scene.add(arcLine);
const marker = new THREE.Mesh(new THREE.RingGeometry(0.25,0.30,32), new THREE.MeshBasicMaterial({ color:0x7ad1ff, transparent:true, opacity:0.9, side:THREE.DoubleSide }));
marker.rotation.x = -Math.PI/2; marker.visible=false; scene.add(marker);

let teleportValid = false;
const teleportPoint = new THREE.Vector3();

controllerRight.addEventListener('selectstart', ()=>{ arcLine.visible=true; marker.visible=true; });
controllerRight.addEventListener('selectend', ()=>{
  arcLine.visible=false; marker.visible=false;
  if (teleportValid){
    // Verificar que la posición de teleport esté en el suelo del laberinto
    const floorY = -0.1 + 1.6; // Altura del piso + altura del jugador
    player.position.set(teleportPoint.x, floorY, teleportPoint.z);
    
    // Verificar colisiones después del teleport
    player.position.copy(resolveCollisions(player.position, player.position));
  }
});

// Audio ambiente al entrar a VR
renderer.xr.addEventListener('sessionstart', async ()=>{
  try { if (ambientEl) { ambientEl.volume = 0.4; await ambientEl.play(); } } catch(e){ console.warn('Audio bosque bloqueado:', e); }
  startAmbientAudio();
});

/** ========= LOCOMOCIÓN (stick) ========= */
function vrGamepadMove(dt){
  const session = renderer.xr.getSession(); if (!session) return;
  for (const src of session.inputSources){
    if (!src.gamepad) continue;
    let [x,y] = [src.gamepad.axes[2], src.gamepad.axes[3]];
    if (x===undefined || y===undefined){ x = src.gamepad.axes[0] ?? 0; y = src.gamepad.axes[1] ?? 0; }
    const dead=0.12; if (Math.abs(x)<dead) x=0; if (Math.abs(y)<dead) y=0; if (x===0 && y===0) continue;

    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    let next = player.position.clone();
    next.addScaledVector(forward, -y * CONFIG.VR_WALK_SPEED * dt);
    next.addScaledVector(right,    x * CONFIG.VR_STRAFE_SPEED * dt);

    // Restringir movimiento dentro de los límites del laberinto
    const maze = scene.userData.maze;
    if (maze) {
      const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 5;
      const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 5;
      next.x = Math.max(-halfWidth, Math.min(halfWidth, next.x));
      next.z = Math.max(-halfHeight, Math.min(halfHeight, next.z));
    }

    next.y = -0.1 + 1.6; // Mantener en el suelo
    next = resolveCollisions(player.position, next);
    player.position.copy(next);
  }
}

/** ========= TELEPORT ========= */
const arcPointsBuf = new Float32Array(CONFIG.ARC_STEPS*3);
function updateTeleportArc(){
  if (!arcLine.visible) return;
  teleportValid = false;

  const origin = new THREE.Vector3().setFromMatrixPosition(controllerRight.matrixWorld);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(controllerRight.quaternion).normalize();

  const pts = [];
  let hit = null;
  const v0 = dir.clone().multiplyScalar(CONFIG.ARC_SPEED);
  const g = new THREE.Vector3(0,-CONFIG.ARC_GRAVITY,0);
  let p = origin.clone(), v = v0.clone();

  for (let i=0;i<CONFIG.ARC_STEPS;i++){
    pts.push(p.clone());
    v.addScaledVector(g, 1/60);
    const np = p.clone().addScaledVector(v, 1/60);
    
    // Verificar colisión con el piso
    if (np.y <= -0.1) {
      hit = { point: new THREE.Vector3(np.x, -0.1, np.z), faceNormal: new THREE.Vector3(0,1,0) };
      break;
    }
    p.copy(np);
  }

  for (let i=0;i<CONFIG.ARC_STEPS;i++){
    const P = pts[Math.min(i, pts.length-1)];
    arcPointsBuf[i*3+0]=P.x; arcPointsBuf[i*3+1]=P.y; arcPointsBuf[i*3+2]=P.z;
  }
  arcGeo.setAttribute('position', new THREE.BufferAttribute(arcPointsBuf,3));
  arcGeo.attributes.position.needsUpdate = true;

  if (hit){
    // Verificar que el punto esté dentro del laberinto
    const maze = scene.userData.maze;
    let inside = true;
    if (maze) {
      const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 2;
      const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 2;
      inside = Math.abs(hit.point.x) <= halfWidth && Math.abs(hit.point.z) <= halfHeight;
    }
    
    teleportValid = inside;

    arcLine.material = teleportValid ? arcMatOK : arcMatBAD;
    marker.material.color.set(teleportValid ? 0x7ad1ff : 0xff5a5a);

    marker.position.set(hit.point.x, -0.1 + 0.02, hit.point.z);
    teleportPoint.copy(hit.point);
  }
}

/** ========= COLISIONES ========= */
function resolveCollisions(curr, next){
  // Paredes del laberinto
  for (const obj of physicsObjects) {
    if (!obj.static) continue;
    
    const box = obj.boundingBox.clone();
    const playerBox = new THREE.Box3(
      new THREE.Vector3(next.x - CONFIG.PLAYER_RADIUS, next.y - 1.6, next.z - CONFIG.PLAYER_RADIUS),
      new THREE.Vector3(next.x + CONFIG.PLAYER_RADIUS, next.y, next.z + CONFIG.PLAYER_RADIUS)
    );
    
    if (box.intersectsBox(playerBox)) {
      // Resolver colisión empujando al jugador
      const dx = next.x - obj.mesh.position.x;
      const dz = next.z - obj.mesh.position.z;
      const dist = Math.hypot(dx, dz);
      const minDist = CONFIG.PLAYER_RADIUS + CONFIG.WALL_THICKNESS/2;
      
      if (dist < minDist && dist > 0) {
        const push = (minDist - dist) + 0.1;
        const nx = dx / dist;
        const nz = dz / dist;
        next.x += nx * push;
        next.z += nz * push;
      }
    }
  }
  
  // Enemigos
  for (const enemy of enemies) {
    if (!enemy.userData.alive) continue;
    
    const dx = next.x - enemy.position.x;
    const dz = next.z - enemy.position.z;
    const dist = Math.hypot(dx, dz);
    const minDist = CONFIG.PLAYER_RADIUS + 7.5; // Radio del enemigo
    
    if (dist < minDist) {
      // Empujar al jugador lejos del enemigo
      const push = (minDist - dist) + 0.1;
      const nx = dx / (dist || 1);
      const nz = dz / (dist || 1);
      next.x += nx * push;
      next.z += nz * push;
      
      // Daño al jugador (simulado - podrías agregar sistema de salud)
      console.log("¡Colisión con enemigo!");
    }
  }
  
  return next;
}

/** ========= LOOP ========= */
const clock = new THREE.Clock();

// Inicializar el juego
createGameScene();

renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 0.05);

  if (renderer.xr.isPresenting){
    vrGamepadMove(dt);
    updateTeleportArc();
  }

  // Mantener el fondo centrado en el jugador
  const p = player.position;
  skyMesh.position.copy(p);
  starField.position.copy(p);

  // Animar partículas del portal
  animatePortalParticles(dt);

  // Render: primero fondo, luego mundo
  renderer.clear();
  bgCam.projectionMatrix.copy(camera.projectionMatrix);
  bgCam.matrixWorld.copy(camera.matrixWorld);
  bgCam.matrixWorldInverse.copy(camera.matrixWorldInverse);
  renderer.render(bgScene, bgCam);
  renderer.render(scene, camera);
});

/** ========= RESIZE ========= */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  bgCam.aspect = innerWidth / innerHeight;
  bgCam.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
    </script>
</body>
</html>
