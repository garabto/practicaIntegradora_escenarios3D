<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Alienrinto VR</title>
    <link rel="icon" type="image" href="assets/icono.png">
    <style>
        /* Estilos generales del cuerpo: tipografía Arial, fondo negro, sin márgenes */
        body { margin:0; background:#000; color:#fff; font-family: Arial, sans-serif; overflow:hidden; }
        
        /* Contenedor de información simple (esquina superior izquierda) */
        #info { position:absolute; top:8px; left:8px; z-index:10; background:rgba(0,0,0,0.4); padding:8px; border-radius:6px; font-size: 14px; }
        
        /* UI: contadores */
        #hud { 
            position: fixed;
            left: 20px; 
            top: 20px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .badge {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff4444;
            border-radius: 12px;
            padding: 12px 20px;
            min-width: 180px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }

        .badge span {
            color: #ff8888;
            font-size: 16px;
            font-weight: normal;
            margin-right: 10px;
        }

        .badge b {
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.7);
        }
        
        /* Mensajes centrales (¡GANASTE! / GAME OVER) */
        #message { 
            position: absolute; 
            left:50%; 
            top:45%; 
            transform:translateX(-50%); 
            z-index:12000;
            pointer-events:none; 
            font-size:28px; 
            background:rgba(0,0,0,0.8); 
            padding:12px 20px; 
            border-radius:8px; 
            display:none; 
            white-space: pre-wrap;
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            padding: 25px 50px;
            border: 4px solid;
            border-radius: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* -------- PORTADA INICIAL -------- */
        #portada {
            position: fixed;
            inset: 0;
            background: rgb(0, 0, 0);
            background-size: cover;
            background-blend-mode: overlay;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            text-align: center;
            padding: 20px;
        }
        
        #portada-content {
            max-width: 700px;
            background: rgba(0,0,0,0.6);
            padding: 40px;
            border-radius: 14px;
            box-shadow: 0 0 20px rgba(0,255,150,0.4);
            border: 1px solid #22ff88;
        }

        #portada h1 {
            font-size: 48px;
            color: #22ff88;
            margin-bottom: 10px;
        }

        #portada .sub {
            font-size: 18px;
            margin-bottom: 18px;
            color: #ccc;
        }

        #portada h2 {
            margin-top: 20px;
            color: #22ff88;
        }

        #portada ul {
            list-style: none;
            padding: 0;
        }

        #portada ul li {
            margin: 6px 0;
        }

        #portada .equipo {
            color: #ddd;
            line-height: 1.6;
        }

        #startBtn {
            margin-top: 28px;
            padding: 12px 32px;
            font-size: 18px;
            border: none;
            background: #22ff88;
            color: #000;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s ease;
            font-weight: bold;
        }

        #startBtn:hover {
            background: #44ffaa;
        }

        .vr-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            transition: all 0.3s ease;
            display: none;
        }

        .vr-button:hover {
            background: linear-gradient(45deg, #1976D2, #1E88E5);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.6);
        }

        .vr-button:active {
            transform: translateY(0);
        }
        
        /* Mira del jugador (cruz en el centro) */
        .crosshair { 
            position: absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
            width:12px; 
            height:12px; 
            z-index:9; 
            pointer-events:none; 
            opacity:0.85; 
            display: none;
        }
        .crosshair:before, .crosshair:after { content:""; position:absolute; background:#fff; }
        .crosshair:before { left:50%; top:0; width:2px; height:100%; transform:translateX(-50%); }
        .crosshair:after  { top:50%; left:0; height:2px; width:100%; transform:translateY(-50%); }
        
        /* Pie de página (Footer) para créditos y controles */
        footer { 
            position:fixed; 
            left:0; 
            right:0; 
            bottom:0; 
            background:rgba(0,0,0,0.6); 
            color:#fff; 
            padding:10px 16px; 
            display:flex; 
            justify-content:space-between; 
            align-items:center; 
            z-index:5; 
            font-family: Arial, sans-serif;
            display: none;
        }
        
        /* Estilo para el <h1> del Título */
        footer h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            font-weight: bold;
            color: #22ff88;
        }

        /* Estilo para el "Tablero de Teclas" */
        #key-board {
            font-size: 12px;
            line-height: 1.5;
        }
        #key-board strong {
            color: #22ff88;
            min-width: 60px;
            display: inline-block;
        }

        /* Estilo para la info del Equipo */
        #team-info {
            text-align: right;
            font-size: 13px;
            line-height: 1.5;
        }
        
        canvas { 
            display:none; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Botón de reinicio */
        #restartBtn {
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #22ff88;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            display: none;
            z-index: 13000;
        }

        #restartBtn:hover {
            background: #44ffaa;
        }

        /* Información VR */
        #vr-info { 
            position: absolute; 
            top: 80px; 
            right: 20px; 
            background: rgba(0,0,0,0.7); 
            padding: 15px; 
            border-radius: 8px; 
            z-index: 11; 
            display: none; 
        }

        /* Letrero VR simplificado */
        #vr-enter-sign {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid #ff4444;
            z-index: 20000;
            text-align: center;
            font-family: Arial, sans-serif;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.7);
            display: none;
            width: 400px;
            max-width: 90vw;
            backdrop-filter: blur(10px);
        }
        
        #vr-enter-sign h2 {
            color: #ff4444;
            margin: 0 0 20px 0;
            font-size: 32px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #vr-enter-sign .stats {
            font-size: 24px;
            margin: 15px 0;
            line-height: 1.6;
            font-weight: bold;
        }
        
        #vr-enter-sign .stats span {
            color: #ff8888;
            font-weight: bold;
        }
        
        #close-vr-sign {
            margin-top: 25px;
            padding: 10px 30px;
            font-size: 16px;
            border: none;
            background: #ff4444;
            color: #000;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.3s ease;
            font-weight: bold;
        }
        
        #close-vr-sign:hover {
            background: #ff6666;
        }
    </style>

    <!-- Importar Three.js desde CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/"
        }
    }
    </script>

</head>
<body>
    <!-- Audio -->
    <audio id="shootSound" src="assets/Disparo.mp3"></audio>
    <audio id="explosionSound" src="assets/Explosion.mp3"></audio>
    <audio id="backgroundMusic" loop>
        <source src="assets/musica.mp3" type="audio/mpeg">
    </audio>

    <!-- PORTADA INICIAL -->
    <div id="portada">
        <div id="portada-content">
            <h1>Alienrinto VR</h1>
            <p class="sub"> >>>>>> Experiencia VR para Meta Quest 3 <<<<<< </p>

            <h2>Instrucciones VR</h2>
            <ul>
                <li><strong>Joystick izquierdo</strong> - Movimiento</li>
                <li><strong>Gatillo derecho</strong> - Disparar</li>
                <li><strong>Botón A/X</strong> - Saltar</li>
                <li><strong>Botón de menú</strong> - Pausa/Salir VR</li>
            </ul>
            <h2>Objetivo:</h2>
            <p>Llega al portal sin morir en el intento</p>

            <h2>Integrantes del Equipo</h2>
            <p class="equipo">
                23200860 – Marquez Zempoalteca Judith<br>
                23200823 – Cruz Monter Sergio Eloy<br>
                23200904 – Veloz Pérez Mariana
            </p>

            <button id="startBtn">Iniciar Experiencia VR</button>
        </div>
    </div>

    <!-- UI: contadores -->
    <div id="hud">
        <div class="badge"><span>Total enemigos:</span> <b id="totalEnemies">0</b></div>
        <div class="badge"><span>Eliminados:</span> <b id="hitEnemies">0</b></div>
    </div>

    <!-- Mensajes -->
    <div id="message"></div>
    <button id="restartBtn">Jugar Otra Vez</button>

    <!-- Información VR -->
    <div id="vr-info">
        <h3>Controles Quest 3</h3>
        <ul>
            <li><strong>Joystick:</strong> Moverse</li>
            <li><strong>Gatillo derecho:</strong> Disparar</li>
            <li><strong>Botón A/X:</strong> Saltar</li>
        </ul>
    </div>

    <!-- Mira -->
    <div class="crosshair"></div>

    <!-- Letrero VR temporal -->
    <div id="vr-enter-sign">
        <h2>MODO VR ACTIVADO</h2>
        
        <div class="stats">
            Enemigos: <span id="vr-total">0</span> / <span id="vr-hit">0</span>
        </div>
        
        <div class="stats" style="margin-top: 25px;">
            Objetivo: Encuentra y destruye a todos los enemigos
        </div>
        
        <button id="close-vr-sign">Continuar</button>
    </div>

    <!-- Canvas para Three.js -->
    <canvas id="scene"></canvas>

    <script type="module">
// -------------------------------------------------------------------
// ---------- CONFIGURACIÓN ----------
// -------------------------------------------------------------------
const CONFIG = {
    // Laberinto
    MAZE_COLS: 11,
    MAZE_ROWS: 11,
    CELL_SIZE: 80,
    WALL_HEIGHT: 20,
    WALL_THICKNESS: 8,
    
    // Enemigos
    ENEMY_COUNT: 15,
    ENEMY_HEALTH: 50,
    ENEMY_SPEED_MIN: 0.8,
    ENEMY_SPEED_MAX: 1.6,
    ENEMY_SIGHT_RANGE: 400,
    ENEMY_ATTACK_RANGE: 15,
    ENEMY_ATTACK_DAMAGE: 8,
    
    // Texturas
    FLOOR_TEX: 'models/rgbe/piso.jpg',
    WALL_TEX: 'models/rgbe/paredes.jpg',
    
    // VR
    PLAYER_RADIUS: 0.35,
    VR_WALK_SPEED: 5.5,
    VR_STRAFE_SPEED: 4.8,
    
    // Otros
    FOG_DENSITY: 0.005, // BRUMA MUY CLARA PARA DÍA
    ARC_STEPS: 40,
    ARC_SPEED: 7.5,
    ARC_GRAVITY: 9.8,
    MAX_SLOPE_DEG: 45
};

// Importar módulos necesarios
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

// Variables globales
let scene, camera, player, renderer;
let physicsObjects = [];
let enemies = [];
let gameInitialized = false;
let clock = new THREE.Clock();
let bgScene, bgCam, skyMesh, starField;
let mainLight, hemiLight;
let listener;
let controllerLeft, controllerRight, grip0, grip1;
let arcLine, marker, teleportPoint;
let teleportValid = false;
let arcPointsBuf;
let arcMatOK, arcMatBAD, arcGeo;
let vrButton;
let isInVRMode = false;

// UI Elements
const hudTotal = document.getElementById('totalEnemies');
const hudHit = document.getElementById('hitEnemies');
let hitCount = 0;

/** ========= INICIALIZAR RENDERER ========= */
function initRenderer() {
    const canvas = document.getElementById('scene');
    
    try {
        renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true,
            alpha: true
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.xr.enabled = true;
        renderer.autoClear = false;
        
        console.log("Renderer inicializado correctamente");
        return renderer;
    } catch (error) {
        console.error("Error al inicializar renderer:", error);
        alert("Error al inicializar WebGL. Verifica que tu navegador soporte WebGL y prueba en Chrome o Firefox.");
        throw error;
    }
}

/** ========= INICIALIZAR ESCENAS ========= */
function initScenes() {
    // Escena principal
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Color celeste para día
    scene.fog = new THREE.FogExp2(0xD8EFFF, CONFIG.FOG_DENSITY); // BRUMA AZUL MUY CLARA
    
    // Escena de fondo
    bgScene = new THREE.Scene();
    bgCam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    
    // Cámara del jugador
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
    player = new THREE.Group();
    player.add(camera);
    scene.add(player);
    
    console.log("Escenas inicializadas");
}

/** ========= INICIALIZAR LUCES - DÍA BRILLANTE (11-12 am) ========= */
function initLights() {
    // Luz ambiental diurna muy brillante
    const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.8); // MUY BRILLANTE PARA DÍA
    scene.add(ambientLight);
    
    // Luz hemisférica para día
    hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x90EE90, 1.0); // Cielo azul, suelo verde claro
    scene.add(hemiLight);
    
    // Luz direccional principal (sol del mediodía)
    mainLight = new THREE.DirectionalLight(0xFFF8DC, 1.5); // Color cálido de sol, muy brillante
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 500;
    mainLight.position.set(50, 100, 50); // Sol muy alto (mediodía)
    
    // Configurar sombras (sombras cortas para mediodía)
    mainLight.shadow.camera.left = -100;
    mainLight.shadow.camera.right = 100;
    mainLight.shadow.camera.top = 100;
    mainLight.shadow.camera.bottom = -100;
    mainLight.shadow.bias = -0.001;
    
    scene.add(mainLight);
    
    // Luz del portal (mantener)
    const portalLight = new THREE.PointLight(0x22ff88, 1.5, 200);
    portalLight.position.set(0, 20, 0);
    scene.add(portalLight);
    
    console.log("Iluminación diurna brillante (11-12 am) inicializada");
}

/** ========= INICIALIZAR CIELO ========= */
function initSky() {
    try {
        // Usar color celeste para simular día brillante
        scene.background = new THREE.Color(0x87CEEB);
        scene.environment = null;
        
        // Crear cielo diurno simple
        const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
        const skyMat = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        
        skyMesh = new THREE.Mesh(skyGeo, skyMat);
        skyMesh.renderOrder = -2;
        bgScene.add(skyMesh);
        
        // Crear nubes simples para ambiente diurno
        createClouds();
        
        // Estrellas (muy tenues para día)
        const starCount = 100; // Muy pocas para día
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = 900 + Math.random() * 200;
            const a = Math.random() * Math.PI * 2;
            const b = Math.acos(2 * Math.random() - 1);
            starPositions[i * 3] = r * Math.sin(b) * Math.cos(a);
            starPositions[i * 3 + 1] = r * Math.cos(b);
            starPositions[i * 3 + 2] = r * Math.sin(b) * Math.sin(a);
        }
        
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMat = new THREE.PointsMaterial({
            size: 1.0,
            sizeAttenuation: false,
            color: 0xFFFFFF,
            fog: false,
            transparent: true,
            opacity: 0.05 // CASI INVISIBLES PARA DÍA
        });
        
        starField = new THREE.Points(starGeo, starMat);
        starField.renderOrder = -1;
        bgScene.add(starField);
        
    } catch (error) {
        console.error("Error al inicializar cielo:", error);
        scene.background = new THREE.Color(0x87CEEB);
    }
}

/** ========= CREAR NUBES ========= */
function createClouds() {
    const cloudCount = 20; // Más nubes para día
    
    for (let i = 0; i < cloudCount; i++) {
        const cloudGroup = new THREE.Group();
        
        // Crear varias esferas para formar una nube
        for (let j = 0; j < 6; j++) {
            const size = 20 + Math.random() * 15;
            const cloudGeo = new THREE.SphereGeometry(size, 8, 8);
            const cloudMat = new THREE.MeshLambertMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8 // Nubes más opacas para día
            });
            
            const cloudPart = new THREE.Mesh(cloudGeo, cloudMat);
            cloudPart.position.set(
                (Math.random() - 0.5) * 40,
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 40
            );
            cloudGroup.add(cloudPart);
        }
        
        // Posicionar nube aleatoriamente en el cielo
        const radius = 300 + Math.random() * 200;
        const angle = Math.random() * Math.PI * 2;
        const height = 150 + Math.random() * 150; // Nubes más altas para día
        
        cloudGroup.position.set(
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
        );
        
        bgScene.add(cloudGroup);
        
        // Animación simple de nubes
        cloudGroup.userData.speed = 0.05 + Math.random() * 0.1;
        cloudGroup.userData.angle = angle;
        cloudGroup.userData.radius = radius;
    }
}

/** ========= INICIALIZAR AUDIO ========= */
function initAudio() {
    try {
        listener = new THREE.AudioListener();
        camera.add(listener);
        
        // Iniciar música de fondo
        const backgroundMusic = document.getElementById('backgroundMusic');
        if (backgroundMusic) {
            backgroundMusic.volume = 0.3;
            backgroundMusic.play().catch(e => console.log('Audio bloqueado, requiere interacción del usuario:', e));
        }
        
        console.log("Audio inicializado");
    } catch (error) {
        console.error("Error al inicializar audio:", error);
    }
}

/** ========= DISPARAR - CON SONIDOS ========= */
function shoot() {
    // Reproducir sonido de disparo
    const shootSound = document.getElementById('shootSound');
    if (shootSound) {
        shootSound.currentTime = 0;
        shootSound.play().catch(e => console.log('Error al reproducir sonido de disparo:', e));
    }
    
    // Lógica de disparo
    if (camera && enemies.length > 0) {
        const raycaster = new THREE.Raycaster();
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        raycaster.set(camera.position, direction);
        
        const intersects = raycaster.intersectObjects(enemies);
        
        if (intersects.length > 0) {
            const enemy = intersects[0].object;
            
            if (enemy.userData.alive) {
                // Aplicar daño
                enemy.userData.health -= 25;
                
                // Reproducir sonido de explosión
                const explosionSound = document.getElementById('explosionSound');
                if (explosionSound) {
                    explosionSound.currentTime = 0;
                    explosionSound.play().catch(e => console.log('Error al reproducir explosión:', e));
                }
                
                // Efecto visual de daño (cubo se vuelve blanco momentáneamente)
                enemy.material.emissive.setHex(0xffffff);
                setTimeout(() => {
                    if (enemy.material) {
                        enemy.material.emissive.setHex(0x220000);
                    }
                }, 100);
                
                // Verificar si el enemigo murió
                if (enemy.userData.health <= 0) {
                    enemy.userData.alive = false;
                    enemy.visible = false;
                    
                    // Reproducir sonido de muerte
                    const deathSound = document.getElementById('enemyDeathSound');
                    if (deathSound) {
                        deathSound.currentTime = 0;
                        deathSound.play().catch(e => console.log('Error al reproducir muerte:', e));
                    }
                    
                    // Actualizar contador
                    hitCount++;
                    updateHUD();
                    
                    // Crear partículas de muerte
                    spawnParticles(enemy.position.clone());
                }
                
                // Actualizar HUD
                updateHUD();
            }
        }
    }
}

/** ========= CREAR PARTÍCULAS DE MUERTE ========= */
function spawnParticles(position) {
    const particleCount = 20;
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = position.x + (Math.random() - 0.5) * 10;
        positions[i * 3 + 1] = position.y + (Math.random() - 0.5) * 10;
        positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 10;
        
        // Colores rojos para enemigos
        colors[i * 3] = 0.8 + Math.random() * 0.2; // Rojo
        colors[i * 3 + 1] = Math.random() * 0.2; // Poco verde
        colors[i * 3 + 2] = Math.random() * 0.2; // Poco azul
    }
    
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMat = new THREE.PointsMaterial({
        size: 2.0,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
    });
    
    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);
    
    // Remover partículas después de un tiempo
    setTimeout(() => {
        scene.remove(particles);
        particleGeo.dispose();
        particleMat.dispose();
    }, 1000);
}

/** ========= CONTROL DE DISPARO EN VR ========= */
function initVRShooting() {
    if (controllerRight) {
        controllerRight.addEventListener('selectstart', () => {
            shoot();
            
            // Disparo continuo mientras se mantiene presionado
            controllerRight.userData.shootingInterval = setInterval(shoot, 200);
        });
        
        controllerRight.addEventListener('selectend', () => {
            // Detener disparo continuo
            if (controllerRight.userData.shootingInterval) {
                clearInterval(controllerRight.userData.shootingInterval);
                controllerRight.userData.shootingInterval = null;
            }
        });
    }
    
    // También disparar con clic del mouse (para pruebas en desktop)
    document.addEventListener('click', (e) => {
        if (!renderer.xr.isPresenting && gameInitialized) {
            shoot();
        }
    });
    
    // Disparar con barra espaciadora (para pruebas en desktop)
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !renderer.xr.isPresenting && gameInitialized) {
            shoot();
            e.preventDefault();
        }
    });
}

/** ========= INICIALIZAR VR ========= */
function initVR() {
    try {
        // Botón VR
        vrButton = VRButton.createButton(renderer);
        vrButton.classList.add('vr-button');
        vrButton.style.display = 'block';
        document.body.appendChild(vrButton);
        
        console.log("Botón VR creado");
        
        // Evento cuando se entra en VR
        vrButton.addEventListener('click', () => {
            setTimeout(() => {
                if (renderer.xr.isPresenting) {
                    setTimeout(() => {
                        showVREnterSign();
                    }, 1000);
                }
            }, 500);
        });
        
        // Esperar a que el renderer esté listo
        setTimeout(() => {
            // Controladores
            controllerLeft = renderer.xr.getController(0);
            controllerRight = renderer.xr.getController(1);
            
            if (controllerLeft && controllerRight) {
                scene.add(controllerLeft);
                scene.add(controllerRight);
                
                const controllerModelFactory = new XRControllerModelFactory();
                
                grip0 = renderer.xr.getControllerGrip(0);
                grip0.add(controllerModelFactory.createControllerModel(grip0));
                scene.add(grip0);
                
                grip1 = renderer.xr.getControllerGrip(1);
                grip1.add(controllerModelFactory.createControllerModel(grip1));
                scene.add(grip1);
                
                console.log("Controladores VR inicializados");
                
                // Arco de teleport
                arcMatOK = new THREE.LineBasicMaterial({ 
                    color: 0x7ad1ff, 
                    transparent: true, 
                    opacity: 0.95 
                });
                arcMatBAD = new THREE.LineBasicMaterial({ 
                    color: 0xff5a5a, 
                    transparent: true, 
                    opacity: 0.95 
                });
                
                arcGeo = new THREE.BufferGeometry().setFromPoints(
                    new Array(CONFIG.ARC_STEPS).fill(0).map(() => new THREE.Vector3())
                );
                arcLine = new THREE.Line(arcGeo, arcMatOK);
                arcLine.visible = false;
                scene.add(arcLine);
                
                marker = new THREE.Mesh(
                    new THREE.RingGeometry(0.25, 0.30, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x7ad1ff, 
                        transparent: true, 
                        opacity: 0.9, 
                        side: THREE.DoubleSide 
                    })
                );
                marker.rotation.x = -Math.PI / 2;
                marker.visible = false;
                scene.add(marker);
                
                teleportPoint = new THREE.Vector3();
                arcPointsBuf = new Float32Array(CONFIG.ARC_STEPS * 3);
                
                // Eventos de teleport
                controllerRight.addEventListener('selectstart', () => { 
                    arcLine.visible = true; 
                    marker.visible = true; 
                });
                
                controllerRight.addEventListener('selectend', () => {
                    arcLine.visible = false;
                    marker.visible = false;
                    if (teleportValid) {
                        const floorY = -0.1 + 1.6;
                        player.position.set(teleportPoint.x, floorY, teleportPoint.z);
                        player.position.copy(resolveCollisions(player.position, player.position));
                    }
                });
                
                // Inicializar sistema de disparo
                initVRShooting();
                
                console.log("Sistema de teleport y disparo inicializado");
            } else {
                console.warn("Controladores VR no disponibles");
            }
        }, 100);
        
    } catch (error) {
        console.error("Error al inicializar VR:", error);
        const fallbackVRButton = document.createElement('button');
        fallbackVRButton.textContent = 'VR NO DISPONIBLE';
        fallbackVRButton.classList.add('vr-button');
        fallbackVRButton.style.background = '#ff4444';
        fallbackVRButton.style.cursor = 'not-allowed';
        document.body.appendChild(fallbackVRButton);
    }
}

/** ========= FUNCIÓN PARA MOSTRAR LETRERO VR ========= */
function showVREnterSign() {
    const vrSign = document.getElementById('vr-enter-sign');
    const vrTotal = document.getElementById('vr-total');
    const vrHit = document.getElementById('vr-hit');
    const closeButton = document.getElementById('close-vr-sign');
    
    if (vrSign && vrTotal && vrHit && closeButton) {
        // Actualizar valores
        vrTotal.textContent = CONFIG.ENEMY_COUNT;
        vrHit.textContent = hitCount;
        
        // Mostrar letrero
        vrSign.style.display = 'block';
        
        console.log("Letrero VR mostrado");
        
        // Forzar que el HUD esté visible
        const hud = document.getElementById('hud');
        if (hud) {
            hud.style.display = 'flex';
        }
        
        // Configurar botón de cierre
        closeButton.onclick = hideVREnterSign;
    }
}

/** ========= OCULTAR LETRERO VR ========= */
function hideVREnterSign() {
    const vrSign = document.getElementById('vr-enter-sign');
    if (vrSign) {
        vrSign.style.display = 'none';
        console.log("Letrero VR ocultado");
    }
}

// -------------------------------------------------------------------
// ---------- GENERACIÓN DEL LABERINTO ----------
// -------------------------------------------------------------------
/** ========= GENERACIÓN DEL LABERINTO (SIN PISTAS FLOTANTES) ========= */
function generateMaze(rows, cols, cellSize) {
    console.log(`Generando laberinto ${rows}x${cols}...`);
    
    const grid = [];
    for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
            grid[r][c] = { 
                r, c, 
                visited: false, 
                walls: [true, true, true, true]
            };
        }
    }
    
    const stack = [];
    let current = grid[0][0];
    current.visited = true;
    
    function getNeighbors(cell) {
        const n = [];
        const { r, c } = cell;
        
        if (r > 0 && !grid[r - 1][c].visited) n.push(grid[r - 1][c]);
        if (c < cols - 1 && !grid[r][c + 1].visited) n.push(grid[r][c + 1]);
        if (r < rows - 1 && !grid[r + 1][c].visited) n.push(grid[r + 1][c]);
        if (c > 0 && !grid[r][c - 1].visited) n.push(grid[r][c - 1]);
        
        return n;
    }
    
    while (true) {
        const neighbors = getNeighbors(current);
        
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);
            
            const dr = next.r - current.r;
            const dc = next.c - current.c;
            
            if (dr === -1) {
                current.walls[0] = false;
                next.walls[2] = false;
            } else if (dc === 1) {
                current.walls[1] = false;
                next.walls[3] = false;
            } else if (dr === 1) {
                current.walls[2] = false;
                next.walls[0] = false;
            } else if (dc === -1) {
                current.walls[3] = false;
                next.walls[1] = false;
            }
            
            current = next;
            current.visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }
    
    const startX = -(cols * cellSize) / 2;
    const startZ = -(rows * cellSize) / 2;
    const wallHeightHalf = CONFIG.WALL_HEIGHT / 2;
    
    const wallGeo = new THREE.BoxGeometry(
        cellSize + CONFIG.WALL_THICKNESS, 
        CONFIG.WALL_HEIGHT,
        CONFIG.WALL_THICKNESS
    );
    
    // Cargar textura de paredes
    const textureLoader = new THREE.TextureLoader();
    let wallMaterial;
    
    try {
        const wallTexture = textureLoader.load(CONFIG.WALL_TEX, 
            (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                const repeatX = (cellSize + CONFIG.WALL_THICKNESS) / 50;
                const repeatY = CONFIG.WALL_HEIGHT / 50;
                texture.repeat.set(repeatX, repeatY);
                console.log("Textura de paredes cargada correctamente");
            },
            undefined,
            (error) => {
                console.warn("Error al cargar textura de paredes:", error);
                wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0xAAAAAA, // Color gris claro para día
                    roughness: 0.7,
                    metalness: 0.1
                });
            }
        );
        
        wallMaterial = new THREE.MeshStandardMaterial({
            map: wallTexture,
            roughness: 0.7,
            metalness: 0.1
        });
    } catch (error) {
        console.warn("Error al crear material:", error);
        wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA,
            roughness: 0.7,
            metalness: 0.1
        });
    }
    
    function createWall(posX, posZ, rotY) {
        const wall = new THREE.Mesh(wallGeo, wallMaterial);
        wall.position.set(posX, wallHeightHalf, posZ);
        wall.rotation.y = rotY;
        wall.receiveShadow = true;
        wall.castShadow = true;
        scene.add(wall);
        
        wall.updateMatrixWorld();
        const wallBox = new THREE.Box3().setFromObject(wall);
        physicsObjects.push({ 
            mesh: wall, 
            boundingBox: wallBox, 
            static: true 
        });
        
        return wall;
    }
    
    // Crear todas las paredes internas
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = grid[r][c];
            const cx = startX + c * cellSize + cellSize / 2;
            const cz = startZ + r * cellSize + cellSize / 2;
            
            if (cell.walls[0]) createWall(cx, cz - cellSize / 2, 0);
            if (cell.walls[1]) createWall(cx + cellSize / 2, cz, Math.PI / 2);
            if (cell.walls[2]) createWall(cx, cz + cellSize / 2, 0);
            if (cell.walls[3]) createWall(cx - cellSize / 2, cz, Math.PI / 2);
        }
    }
    
    scene.userData.maze = { 
        grid, 
        startX, 
        startZ, 
        rows, 
        cols, 
        cellSize
    };
    
    console.log(`Laberinto generado: ${rows}x${cols}`);
    return grid;
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DE ENEMIGOS (CUBOS ROJOS) ----------
// -------------------------------------------------------------------
function spawnEnemiesInMaze(count) {
    const maze = scene.userData.maze;
    if (!maze) {
        console.error("No hay laberinto generado");
        return;
    }
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    // Crear enemigos tipo cubo rojo
    let placed = 0;
    const maxAttempts = count * 10;
    let attempts = 0;
    
    while (placed < count && attempts < maxAttempts) {
        attempts++;
        
        const r = 1 + Math.floor(Math.random() * (rows - 2));
        const c = 1 + Math.floor(Math.random() * (cols - 2));
        
        const x = startX + c * cellSize + cellSize / 2;
        const z = startZ + r * cellSize + cellSize / 2;
        
        const startCellX = startX + cellSize / 2;
        const startCellZ = startZ + cellSize / 2;
        const distanceToStart = Math.hypot(x - startCellX, z - startCellZ);
        
        if (distanceToStart < cellSize * 2) continue;
        
        let tooClose = false;
        for (const enemy of enemies) {
            if (enemy.position.distanceTo(new THREE.Vector3(x, 7.5, z)) < cellSize) {
                tooClose = true;
                break;
            }
        }
        
        if (tooClose) continue;
        
        // Crear enemigo con forma de cubo rojo
        addRedCubeEnemy(x, z);
        placed++;
    }
    
    // Actualizar UI
    if (hudTotal) hudTotal.textContent = String(CONFIG.ENEMY_COUNT);
    if (hudHit) hudHit.textContent = String(hitCount);
    
    console.log(`${placed} enemigos (cubos rojos) colocados en el laberinto`);
}

/** ========= CREAR ENEMIGO CUBO ROJO ========= */
function addRedCubeEnemy(x, z) {
    const y = 7.5;
    
    // Crear material para cubo rojo
    const mat = new THREE.MeshStandardMaterial({
        color: 0xff4444, // ROJO
        roughness: 0.4,
        metalness: 0.2,
        emissive: 0x440000, // Emisión roja tenue
        emissiveIntensity: 0.3
    });
    
    // Cuerpo del cubo
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(15, 15, 15),
        mat
    );
    body.castShadow = true;
    body.receiveShadow = true;
    
    const g = new THREE.Group();
    g.position.set(x, y, z);
    g.add(body);
    
    // Efecto de rotación lenta
    g.userData.rotationSpeed = (Math.random() - 0.5) * 0.02;
    
    g.userData.mat = mat;
    g.userData.alive = true;
    g.userData.health = CONFIG.ENEMY_HEALTH;
    g.userData.speed = CONFIG.ENEMY_SPEED_MIN + Math.random() * (CONFIG.ENEMY_SPEED_MAX - CONFIG.ENEMY_SPEED_MIN);
    g.userData.lastAttack = 0;
    g.userData.touched = false;
    
    scene.add(g);
    enemies.push(g);
    
    // Agregar a física
    g.updateMatrixWorld();
    const enemyBox = new THREE.Box3().setFromObject(g);
    physicsObjects.push({ 
        mesh: g, 
        boundingBox: enemyBox, 
        mass: 50 
    });
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PORTAL ----------
// -------------------------------------------------------------------
function createGoalAtEnd() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    const goalX = startX + (cols - 1) * cellSize + cellSize / 2;
    const goalZ = startZ + (rows - 1) * cellSize + cellSize / 2;
    
    const portalGeo = new THREE.TorusGeometry(30, 6, 16, 100);
    const portalMat = new THREE.MeshStandardMaterial({ 
        color: 0x22ff88, 
        emissive: 0x22ff88, 
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9
    });
    
    const portal = new THREE.Mesh(portalGeo, portalMat);
    portal.rotation.x = Math.PI / 2;
    portal.position.set(goalX, 45, goalZ);
    portal.castShadow = true;
    scene.add(portal);
    
    createPortalParticles(goalX, goalZ);
    
    scene.userData.goal = { 
        mesh: portal, 
        position: new THREE.Vector3(goalX, 0, goalZ),
        radius: 30
    };
    
    console.log(`Portal creado en posición: (${goalX.toFixed(1)}, ${goalZ.toFixed(1)})`);
}

// -------------------------------------------------------------------
// ---------- PARTÍCULAS DEL PORTAL ----------
// -------------------------------------------------------------------
function createPortalParticles(x, z) {
    const particleCount = 30;
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        const radius = 25 + Math.random() * 10;
        const angle = Math.random() * Math.PI * 2;
        const height = 20 + Math.random() * 50;
        
        positions[i * 3] = x + Math.cos(angle) * radius;
        positions[i * 3 + 1] = height;
        positions[i * 3 + 2] = z + Math.sin(angle) * radius;
        
        colors[i * 3] = 0.2;
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 2] = 0.3;
    }
    
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMat = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.7
    });
    
    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);
    
    scene.userData.portalParticles = {
        mesh: particles,
        time: 0,
        positions: positions
    };
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PISO ----------
// -------------------------------------------------------------------
/** ========= CREACIÓN DEL PISO (con textura) ========= */
function createFloor() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { rows, cols, cellSize } = maze;
    
    const floorWidth = cols * cellSize + cellSize * 2;
    const floorHeight = rows * cellSize + cellSize * 2;
    
    // Cargar textura del piso
    const textureLoader = new THREE.TextureLoader();
    const floorTexture = textureLoader.load(CONFIG.FLOOR_TEX, (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(rows / 2, cols / 2);
    });
    
    const floorMat = new THREE.MeshStandardMaterial({ 
        map: floorTexture,
        roughness: 0.9,
        metalness: 0.05
    });
    
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(floorWidth, floorHeight),
        floorMat
    );
    
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    floor.receiveShadow = true;
    scene.add(floor);
    
    console.log(`Piso texturizado creado: ${floorWidth}x${floorHeight}`);
}

// -------------------------------------------------------------------
// ---------- INICIALIZACIÓN DEL ESCENARIO ----------
// -------------------------------------------------------------------
function createGameScene() {
    console.log("Creando escenario del juego...");
    
    // Limpiar escena si ya existe
    physicsObjects = [];
    enemies = [];
    hitCount = 0;
    
    // Generar laberinto (SIN PISTAS FLOTANTES)
    generateMaze(CONFIG.MAZE_ROWS, CONFIG.MAZE_COLS, CONFIG.CELL_SIZE);
    
    // Crear piso
    createFloor();
    
    // Colocar enemigos (cubos rojos)
    spawnEnemiesInMaze(CONFIG.ENEMY_COUNT);
    
    // Crear portal objetivo
    createGoalAtEnd();
    
    // Posicionar al jugador
    const maze = scene.userData.maze;
    if (maze) {
        const startPos = new THREE.Vector3(
            maze.startX + CONFIG.CELL_SIZE / 2,
            10,
            maze.startZ + CONFIG.CELL_SIZE / 2
        );
        player.position.copy(startPos);
        return startPos;
    }
    
    const defaultStart = new THREE.Vector3(0, 10, 0);
    player.position.copy(defaultStart);
    return defaultStart;
}

/** ========= ANIMACIÓN DEL PORTAL ========= */
function animatePortalParticles(deltaTime) {
    const portalParticles = scene.userData.portalParticles;
    if (!portalParticles) return;
    
    portalParticles.time += deltaTime;
    const positions = portalParticles.positions;
    const portalPos = scene.userData.goal.position;
    
    for (let i = 0; i < positions.length / 3; i++) {
        const idx = i * 3;
        const radius = 25 + Math.random() * 10;
        const angle = (portalParticles.time * 0.5 + i * 0.1) % (Math.PI * 2);
        const height = 20 + Math.sin(portalParticles.time + i) * 10;
        
        positions[idx] = portalPos.x + Math.cos(angle) * radius;
        positions[idx + 1] = height;
        positions[idx + 2] = portalPos.z + Math.sin(angle) * radius;
    }
    
    portalParticles.mesh.geometry.attributes.position.needsUpdate = true;
    portalParticles.mesh.rotation.y += deltaTime * 0.2;
    
    if (scene.userData.goal) {
        scene.userData.goal.mesh.rotation.y += deltaTime * 0.5;
    }
}

/** ========= LOCOMOCIÓN VR ========= */
function vrGamepadMove(dt) {
    if (!renderer.xr.isPresenting) return;
    
    const session = renderer.xr.getSession();
    if (!session) return;
    
    for (const src of session.inputSources) {
        if (!src.gamepad) continue;
        
        let [x, y] = [src.gamepad.axes[2], src.gamepad.axes[3]];
        if (x === undefined || y === undefined) {
            x = src.gamepad.axes[0] ?? 0;
            y = src.gamepad.axes[1] ?? 0;
        }
        
        const dead = 0.12;
        if (Math.abs(x) < dead) x = 0;
        if (Math.abs(y) < dead) y = 0;
        if (x === 0 && y === 0) continue;

        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        let next = player.position.clone();
        next.addScaledVector(forward, -y * CONFIG.VR_WALK_SPEED * dt);
        next.addScaledVector(right, x * CONFIG.VR_STRAFE_SPEED * dt);

        const maze = scene.userData.maze;
        if (maze) {
            const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 5;
            const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 5;
            next.x = Math.max(-halfWidth, Math.min(halfWidth, next.x));
            next.z = Math.max(-halfHeight, Math.min(halfHeight, next.z));
        }

        next.y = -0.1 + 1.6;
        next = resolveCollisions(player.position, next);
        player.position.copy(next);
    }
}

/** ========= TELEPORT ========= */
function updateTeleportArc() {
    if (!arcLine || !arcLine.visible) return;
    if (!controllerRight) return;
    
    teleportValid = false;

    const origin = new THREE.Vector3().setFromMatrixPosition(controllerRight.matrixWorld);
    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerRight.quaternion).normalize();

    const pts = [];
    let hit = null;
    const v0 = dir.clone().multiplyScalar(CONFIG.ARC_SPEED);
    const g = new THREE.Vector3(0, -CONFIG.ARC_GRAVITY, 0);
    let p = origin.clone(), v = v0.clone();

    for (let i = 0; i < CONFIG.ARC_STEPS; i++) {
        pts.push(p.clone());
        v.addScaledVector(g, 1 / 60);
        const np = p.clone().addScaledVector(v, 1 / 60);
        
        if (np.y <= -0.1) {
            hit = { point: new THREE.Vector3(np.x, -0.1, np.z), faceNormal: new THREE.Vector3(0, 1, 0) };
            break;
        }
        p.copy(np);
    }

    for (let i = 0; i < CONFIG.ARC_STEPS; i++) {
        const P = pts[Math.min(i, pts.length - 1)];
        arcPointsBuf[i * 3] = P.x;
        arcPointsBuf[i * 3 + 1] = P.y;
        arcPointsBuf[i * 3 + 2] = P.z;
    }
    
    arcGeo.setAttribute('position', new THREE.BufferAttribute(arcPointsBuf, 3));
    arcGeo.attributes.position.needsUpdate = true;

    if (hit) {
        const maze = scene.userData.maze;
        let inside = true;
        if (maze) {
            const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 2;
            const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 2;
            inside = Math.abs(hit.point.x) <= halfWidth && Math.abs(hit.point.z) <= halfHeight;
        }
        
        teleportValid = inside;
        arcLine.material = teleportValid ? arcMatOK : arcMatBAD;
        marker.material.color.set(teleportValid ? 0x7ad1ff : 0xff5a5a);
        marker.position.set(hit.point.x, -0.1 + 0.02, hit.point.z);
        teleportPoint.copy(hit.point);
    }
}

/** ========= COLISIONES ========= */
function resolveCollisions(curr, next) {
    // Paredes del laberinto
    for (const obj of physicsObjects) {
        if (!obj.static) continue;
        
        const box = obj.boundingBox.clone();
        const playerBox = new THREE.Box3(
            new THREE.Vector3(next.x - CONFIG.PLAYER_RADIUS, next.y - 1.6, next.z - CONFIG.PLAYER_RADIUS),
            new THREE.Vector3(next.x + CONFIG.PLAYER_RADIUS, next.y, next.z + CONFIG.PLAYER_RADIUS)
        );
        
        if (box.intersectsBox(playerBox)) {
            const dx = next.x - obj.mesh.position.x;
            const dz = next.z - obj.mesh.position.z;
            const dist = Math.hypot(dx, dz);
            const minDist = CONFIG.PLAYER_RADIUS + CONFIG.WALL_THICKNESS / 2;
            
            if (dist < minDist && dist > 0) {
                const push = (minDist - dist) + 0.1;
                const nx = dx / dist;
                const nz = dz / dist;
                next.x += nx * push;
                next.z += nz * push;
            }
        }
    }
    
    // Enemigos (cubos rojos)
    for (const enemy of enemies) {
        if (!enemy.userData.alive) continue;
        
        const dx = next.x - enemy.position.x;
        const dz = next.z - enemy.position.z;
        const dist = Math.hypot(dx, dz);
        const minDist = CONFIG.PLAYER_RADIUS + 7.5;
        
        if (dist < minDist) {
            const push = (minDist - dist) + 0.1;
            const nx = dx / (dist || 1);
            const nz = dz / (dist || 1);
            next.x += nx * push;
            next.z += nz * push;
            
            // Si el enemigo toca al jugador
            if (!enemy.userData.touched && enemy.userData.alive) {
                enemy.userData.touched = true;
                enemy.userData.mat.color.set(0xff0000); // Rojo más intenso
                enemy.userData.mat.emissive = new THREE.Color(0xff2222);
                enemy.userData.mat.emissiveIntensity = 0.8;
                
                // Daño al jugador
                takeDamage(CONFIG.ENEMY_ATTACK_DAMAGE);
            }
        }
    }
    
    return next;
}

/** ========= ACTUALIZAR HUD COMPLETO ========= */
function updateHUD() {
    if (hudTotal) hudTotal.textContent = String(CONFIG.ENEMY_COUNT);
    if (hudHit) hudHit.textContent = String(hitCount);
    
    // También actualizar el letrero VR si está visible
    const vrSign = document.getElementById('vr-enter-sign');
    if (vrSign && vrSign.style.display === 'block') {
        const vrTotal = document.getElementById('vr-total');
        const vrHit = document.getElementById('vr-hit');
        
        if (vrTotal && vrHit) {
            vrTotal.textContent = CONFIG.ENEMY_COUNT;
            vrHit.textContent = hitCount;
        }
    }
}

/** ========= DAÑO AL JUGADOR ========= */
function takeDamage(amount) {
    // Efecto visual en pantalla
    const hud = document.getElementById('hud');
    if (hud) {
        hud.style.borderColor = '#ff0000';
        hud.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.9)';
        
        setTimeout(() => {
            hud.style.borderColor = '#ff4444';
            hud.style.boxShadow = '0 0 20px rgba(255, 68, 68, 0.4)';
        }, 500);
    }
}

/** ========= CAMBIAR MODO HUD PARA VR ========= */
function setHUDForVR(isVR) {
    const hud = document.getElementById('hud');
    if (!hud) return;
    
    isInVRMode = isVR;
    
    if (isVR) {
        // Modo VR: posicionar mejor para visibilidad
        hud.style.left = '40px';
        hud.style.top = '40px';
        
        // Mostrar siempre en VR
        hud.style.display = 'flex';
        
        console.log("HUD configurado para modo VR");
    } else {
        // Modo escritorio
        hud.style.left = '20px';
        hud.style.top = '20px';
    }
}

/** ========= GAME OVER ========= */
function gameOver() {
    showMessage("GAME OVER", false);
    
    // Detener el juego
    renderer.setAnimationLoop(null);
    
    // Mostrar botón de reinicio
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) {
        restartBtn.style.display = 'block';
        restartBtn.onclick = restartGame;
    }
}

/** ========= REINICIAR JUEGO ========= */
function restartGame() {
    // Ocultar mensaje y botón
    const messageEl = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');
    if (messageEl) messageEl.style.display = 'none';
    if (restartBtn) restartBtn.style.display = 'none';
    
    // Ocultar letrero VR si está visible
    hideVREnterSign();
    
    // Limpiar escena
    while (scene.children.length > 0) {
        const child = scene.children[0];
        if (child !== player && child !== controllerLeft && child !== controllerRight && 
            child !== grip0 && child !== grip1 && child !== arcLine && child !== marker) {
            scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose());
                } else {
                    child.material.dispose();
                }
            }
        }
    }
    
    // Limpiar fondo
    while (bgScene.children.length > 0) {
        const child = bgScene.children[0];
        bgScene.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
            } else {
                child.material.dispose();
            }
        }
    }
    
    // Reinicializar variables
    physicsObjects = [];
    enemies = [];
    hitCount = 0;
    
    // Recrear cielo y nubes
    initSky();
    
    // Crear nuevo escenario
    createGameScene();
    
    // Actualizar HUD
    updateHUD();
    
    // Asegurar que el HUD esté visible
    const hud = document.getElementById('hud');
    if (hud) {
        hud.style.display = 'flex';
    }
    
    // Reiniciar loop
    renderer.setAnimationLoop(gameLoop);
}

/** ========= VICTORIA ========= */
function checkVictory() {
    if (!scene.userData.goal) return;
    
    const distanceToGoal = player.position.distanceTo(scene.userData.goal.position);
    if (distanceToGoal < scene.userData.goal.radius) {
        showMessage("¡VICTORIA!\nPortal alcanzado", true);
        
        // Detener el juego
        renderer.setAnimationLoop(null);
        
        // Mostrar botón de reinicio
        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) {
            restartBtn.style.display = 'block';
            restartBtn.onclick = restartGame;
        }
        
        // Ocultar letrero VR si está visible
        hideVREnterSign();
        
        // Efectos de victoria
        createVictoryEffects();
    }
}

/** ========= EFECTOS DE VICTORIA ========= */
function createVictoryEffects() {
    // Crear confeti
    const confettiCount = 80;
    const confettiGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(confettiCount * 3);
    const colors = new Float32Array(confettiCount * 3);
    
    for (let i = 0; i < confettiCount; i++) {
        const i3 = i * 3;
        positions[i3] = player.position.x + (Math.random() - 0.5) * 50;
        positions[i3 + 1] = player.position.y + Math.random() * 80;
        positions[i3 + 2] = player.position.z + (Math.random() - 0.5) * 50;
        
        colors[i3] = Math.random();
        colors[i3 + 1] = Math.random();
        colors[i3 + 2] = Math.random();
    }
    
    confettiGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    confettiGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const confettiMat = new THREE.PointsMaterial({
        size: 2.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
    });
    
    const confetti = new THREE.Points(confettiGeo, confettiMat);
    scene.add(confetti);
    
    // Animar confeti
    function animateConfetti() {
        const positions = confettiGeo.attributes.position.array;
        for (let i = 0; i < confettiCount; i++) {
            const i3 = i * 3;
            positions[i3 + 1] -= 0.8;
            if (positions[i3 + 1] < player.position.y - 20) {
                positions[i3 + 1] = player.position.y + Math.random() * 80;
            }
        }
        confettiGeo.attributes.position.needsUpdate = true;
        if (confetti.parent) {
            requestAnimationFrame(animateConfetti);
        }
    }
    animateConfetti();
}

/** ========= MOSTRAR MENSAJES ========= */
function showMessage(text, isVictory = false) {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.style.display = 'block';
        messageEl.style.color = isVictory ? '#22ff88' : '#ff4444';
        messageEl.style.borderColor = isVictory ? '#22ff88' : '#ff4444';
        
        if (isVictory) {
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }
    }
}

/** ========= LOOP DEL JUEGO ========= */
function gameLoop() {
    try {
        const dt = Math.min(clock.getDelta(), 0.05);

        if (renderer.xr.isPresenting) {
            vrGamepadMove(dt);
            updateTeleportArc();
        }

        // Mantener fondo centrado
        const p = player.position;
        if (skyMesh) skyMesh.position.copy(p);
        if (starField) starField.position.copy(p);
        
        // Animar nubes
        for (let i = 0; i < bgScene.children.length; i++) {
            const child = bgScene.children[i];
            if (child.userData && child.userData.speed) {
                child.userData.angle += child.userData.speed * dt * 0.01;
                child.position.x = Math.cos(child.userData.angle) * child.userData.radius;
                child.position.z = Math.sin(child.userData.angle) * child.userData.radius;
            }
        }

        // Animar partículas del portal
        animatePortalParticles(dt);
        
        // Animar enemigos (cubos rojos - rotación lenta)
        for (const enemy of enemies) {
            if (enemy.userData.alive && enemy.userData.rotationSpeed) {
                enemy.rotation.y += enemy.userData.rotationSpeed;
            }
        }

        // Actualizar UI
        updateHUD();

        // Verificar victoria (todos los enemigos eliminados)
        const aliveEnemies = enemies.filter(e => e.userData.alive).length;
        if (aliveEnemies === 0) {
            showMessage("¡VICTORIA!\n", true);
            renderer.setAnimationLoop(null);
            
            const restartBtn = document.getElementById('restartBtn');
            if (restartBtn) {
                restartBtn.style.display = 'block';
                restartBtn.onclick = restartGame;
            }
            
            hideVREnterSign();
            createVictoryEffects();
            return;
        }

        // Renderizar
        renderer.clear();
        if (bgCam && camera) {
            bgCam.projectionMatrix.copy(camera.projectionMatrix);
            bgCam.matrixWorld.copy(camera.matrixWorld);
            bgCam.matrixWorldInverse.copy(camera.matrixWorldInverse);
            renderer.render(bgScene, bgCam);
        }
        renderer.render(scene, camera);
    } catch (error) {
        console.error("Error en gameLoop:", error);
    }
}

/** ========= INICIALIZAR JUEGO ========= */
function initGame() {
    if (gameInitialized) {
        console.log("Juego ya inicializado");
        return;
    }
    
    console.log("Iniciando juego...");
    
    try {
        // Ocultar portada
        const portada = document.getElementById('portada');
        portada.style.display = 'none';
        
        // Mostrar elementos del juego
        const canvas = document.getElementById('scene');
        canvas.style.display = 'block';
        
        // Mostrar HUD inmediatamente
        const hud = document.getElementById('hud');
        if (hud) {
            hud.style.display = 'flex';
            setHUDForVR(false);
        }
        
        const crosshair = document.querySelector('.crosshair');
        if (crosshair) crosshair.style.display = 'block';
        
        const footer = document.querySelector('footer');
        if (footer) footer.style.display = 'flex';
        
        const vrInfo = document.getElementById('vr-info');
        if (vrInfo) vrInfo.style.display = 'block';
        
        // Inicializar Three.js
        initRenderer();
        initScenes();
        initLights();
        initSky();
        initAudio();
        initVR();
        
        // Crear escenario del juego
        createGameScene();
        
        // Escuchar cambios en modo VR
        renderer.xr.addEventListener('sessionstart', () => {
            console.log("Sesión VR iniciada");
            setHUDForVR(true);
            setTimeout(() => {
                showVREnterSign();
            }, 1000);
        });
        
        renderer.xr.addEventListener('sessionend', () => {
            console.log("Sesión VR finalizada");
            setHUDForVR(false);
            hideVREnterSign();
        });
        
        // También detectar cuando se presiona el botón VR directamente
        window.addEventListener('vrdisplaypresentchange', () => {
            if (renderer.xr.isPresenting) {
                console.log("VR display present change detectado");
                setTimeout(() => {
                    showVREnterSign();
                }, 1000);
            }
        });
        
        // Iniciar loop del juego
        renderer.setAnimationLoop(gameLoop);
        
        gameInitialized = true;
        
        // Actualizar HUD inicial
        updateHUD();
        
        console.log("Juego inicializado correctamente");
        
        // Activar audio después de interacción del usuario
        document.addEventListener('click', function activateAudio() {
            const backgroundMusic = document.getElementById('backgroundMusic');
            if (backgroundMusic) {
                backgroundMusic.play().catch(e => console.log('Audio activado'));
            }
            document.removeEventListener('click', activateAudio);
        });
        
    } catch (error) {
        console.error("Error al inicializar el juego:", error);
        alert("Error al iniciar el juego: " + error.message);
    }
}

/** ========= RESIZE ========= */
window.addEventListener('resize', () => {
    if (!gameInitialized) return;
    
    if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }
    
    if (bgCam) {
        bgCam.aspect = window.innerWidth / window.innerHeight;
        bgCam.updateProjectionMatrix();
    }
    
    if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
});

/** ========= EVENTOS ========= */
document.addEventListener('DOMContentLoaded', () => {
    console.log("Documento cargado");
    
    // Botón de inicio
    const startBtn = document.getElementById('startBtn');
    if (startBtn) {
        startBtn.addEventListener('click', initGame);
    }
    
    // También permitir iniciar con Enter
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !gameInitialized) {
            initGame();
        }
    });
    
    // Botón de reinicio (oculto inicialmente)
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) {
        restartBtn.onclick = restartGame;
    }
    
    // Configurar botón de cierre del letrero VR
    const closeVRSignBtn = document.getElementById('close-vr-sign');
    if (closeVRSignBtn) {
        closeVRSignBtn.addEventListener('click', hideVREnterSign);
    }
    
    console.log("Listo para iniciar... Presiona el botón 'Iniciar Experiencia VR'");
});
    </script>
</body>
</html>
