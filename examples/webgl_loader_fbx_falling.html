<!DOCTYPE html>
<html lang="es">
<head>
    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Alienrinto</title>
    <link rel="icon" type="image/png" href="assets/icono.png">
    
    <style>
        /* -------- PORTADA INICIAL -------- */
            #portada {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.85);
                background-size: cover;
                background-blend-mode: overlay;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999;
                text-align: center;
                padding: 20px;
            }

            #portada-content {
                max-width: 700px;
                background: rgba(0,0,0,0.6);
                padding: 40px;
                border-radius: 14px;
                box-shadow: 0 0 20px rgba(0,255,150,0.4);
                border: 1px solid #22ff88;
            }

            #portada h1 {
                font-size: 48px;
                color: #22ff88;
                margin-bottom: 10px;
            }

            #portada .sub {
                font-size: 18px;
                margin-bottom: 18px;
                color: #ccc;
            }

            #portada h2 {
                margin-top: 20px;
                color: #22ff88;
            }

            #portada ul {
                list-style: none;
                padding: 0;
            }

            #portada ul li {
                margin: 6px 0;
            }

            #portada .equipo {
                color: #ddd;
                line-height: 1.6;
            }

            #startBtn {
                margin-top: 28px;
                padding: 12px 32px;
                font-size: 18px;
                border: none;
                background: #22ff88;
                color: #000;
                border-radius: 8px;
                cursor: pointer;
                transition: 0.2s ease;
                font-weight: bold;
            }

            #startBtn:hover {
                background: #44ffaa;
            }

        /* Estilos generales del cuerpo: tipografÃ­a Arial, fondo negro, sin mÃ¡rgenes */
        body { margin:0; background:#000; color:#fff; font-family: Arial, sans-serif; overflow:hidden; }
        
        /* Contenedor de informaciÃ³n simple (esquina superior izquierda) */
        #info { position:absolute; top:8px; left:8px; z-index:10; background:rgba(0,0,0,0.4); padding:8px; border-radius:6px; font-size: 14px; }
        
        /* HUD (Head-Up Display): Vida y Enemigos (esquina superior derecha) */
        #hud { position: absolute; right: 12px; top: 12px; z-index:10; background: rgba(0,0,0,0.5); padding:10px; border-radius:6px; text-align:right; min-width:140px; }
        
        /* Mensajes centrales (Â¡GANASTE! / GAME OVER) */
        #message { 
            position: absolute; 
            left:50%; 
            top:45%; 
            transform:translateX(-50%); 
            z-index:12; 
            pointer-events:none; 
            font-size:28px; 
            background:rgba(0,0,0,0.6); 
            padding:12px 20px; 
            border-radius:8px; 
            display:none; 
            white-space: pre-wrap; /* <-- Â¡IMPORTANTE! Permite saltos de lÃ­nea con \n */
            text-align: center;
        }
        
        /* Mira del jugador (cruz en el centro) */
        .crosshair { position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:12px; height:12px; z-index:9; pointer-events:none; opacity:0.85; }
        .crosshair:before, .crosshair:after { content:""; position:absolute; background:#fff; }
        .crosshair:before { left:50%; top:0; width:2px; height:100%; transform:translateX(-50%); }
        .crosshair:after  { top:50%; left:0; height:2px; width:100%; transform:translateY(-50%); }
        
        /* Pie de pÃ¡gina (Footer) para crÃ©ditos y controles */
        footer { 
            position:fixed; 
            left:0; 
            right:0; 
            bottom:0; 
            background:rgba(0,0,0,0.6); 
            color:#fff; 
            padding:10px 16px; 
            display:flex; 
            justify-content:space-between; 
            align-items:center; 
            z-index:5; 
            font-family: Arial, sans-serif; /* Requisito: Arial */
        }
        
        /* Estilo para el <h1> del TÃ­tulo */
        footer h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            font-weight: bold;      /* Requisito: Negrita */
            color: #22ff88;         /* Requisito: Color acorde (verde del portal) */
        }

        /* Estilo para el "Tablero de Teclas" */
        #key-board {
            font-size: 12px;
            line-height: 1.5;
        }
        #key-board strong {
            color: #22ff88;
            min-width: 60px;
            display: inline-block;
        }

        /* Estilo para la info del Equipo */
        #team-info {
            text-align: right;
            font-size: 13px;
            line-height: 1.5;
        }
        
        canvas { display:block; }
        #stats-container { position: absolute; top: 0; left: 0; z-index: 100; }
        
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
</head>

<body>
    <audio id="shootSound" src="assets/Disparo.mp3"></audio>
    <audio id="enemyDeathSound" src="assets/Explosion.mp3"></audio>
    <audio id="backgroundMusic" autoplay loop="">
        <source src="assets/musica.mp3" type="audio/mpeg">
Â Â Â Â </audio>

<!-- PORTADA INICIAL -->
<div id="portada">
    <div id="portada-content">
        <h1>Alienrinto</h1>

        <p class="sub">Laberinto AlienÃ­gena â€“ Juego 3D en VR</p>

        <h2>Instrucciones</h2>
        <ul>
            <li>Usa <strong>W A S D</strong> para moverte</li>
            <li>Presiona <strong>F</strong> para disparar</li>
            <li>Llega al portal sin que los aliens te maten</li>
        </ul>

        <h2>Integrantes del Equipo</h2>
        <p class="equipo">
            23200860 â€“ MÃ¡rquez Zempoalteca Judith<br>
            23200823 â€“ Cruz Monter Sergio Eloy<br>
            23200904 â€“ Veloz PÃ©rez Mariana
        </p>

        <button id="startBtn">Iniciar Juego</button>
    </div>
</div>


    <div id="hud">
        <div><strong>Vida:</strong> <span id="life">100</span></div>
        <div><strong>Enemigos:</strong> <span id="enemiesCount">0</span></div>
        <div style="font-size:12px; margin-top:6px;">Objetivo: llegar al portal al final del laberinto</div>
    </div>

    <div id="message"></div>

    <div class="crosshair"></div>

   <!--<footer>
        <div>
            <h1>Alienrinto: Laberinto AlienÃ­gena</h1>
            
            <div id="key-board">
                <strong>W</strong> - Adelante<br>
                <strong>A</strong> - Izquierda<br>
                <strong>S</strong> - Derecha<br>
                <strong>D</strong> - AtrÃ¡s
            </div>
        </div>
        <div>
            <div id="key-board" style="text-align: right; margin-bottom: 10px;">
                <strong>F</strong> - Disparar<br>
                <strong>1-5</strong> - Cambiar AnimaciÃ³n<br>
                <strong>Click</strong> - Bloquear Cursor
            </div>
        </div>
        <div>
            <div id="team-info">
                <strong>Equipo:</strong><br>
                23200860 - Marquez Zempoalteca Judith<br>
                23200823 - Cruz Monter Sergio Eloy<br>
                23200904 - VelozÂ PÃ©rezÂ Mariana
            </div>
        </div>
    </footer>--> 

    <div id="stats-container"></div>

    <script type="module">
        // ---------- Importaciones de MÃ³dulos de Three.js ----------
        import * as THREE from 'three'; // El nÃºcleo de Three.js
        import Stats from 'three/addons/libs/stats.module.js'; // Medidor de FPS (Stats.js)
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js'; // Controles FPS
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js'; // Cargador para texturas HDR (cielo)
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js'; // Cargador para modelos 3D (personaje)
        //import { SkeletonUtils } from 'three/addons/utils/SkeletonUtils.js'; // <-- Â¡AÃ‘ADE ESTA LÃNEA!
        import { AnimationMixer } from 'three'; // Reproductor de animaciones
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/webxr/VRButton.js';
        window.VRButton = VRButton; // Hacerlo global para tu script

        // -------------------------------------------------------------------
        // ---------- ðŸš€ CONFIGURACIÃ“N GLOBAL DEL JUEGO ----------
        // Centraliza todas las variables "mÃ¡gicas" para fÃ¡cil ajuste.
        // -------------------------------------------------------------------
        const CONFIG = {
            // FÃ­sica y Jugador
            GRAVITY: -30,                 // Fuerza de gravedad
            PLAYER_SPEED: 120,            // Velocidad al caminar
            PLAYER_SPRINT_SPEED: 220,     // Velocidad al correr (Shift)
            PLAYER_JUMP_FORCE: 10,        // Fuerza del salto
            PLAYER_HEIGHT: 18,            // Altura del "hitbox" de colisiÃ³n
            PLAYER_WIDTH: 8,              // Ancho del "hitbox" de colisiÃ³n
            PLAYER_DAMPING: 0.9,          // FricciÃ³n (0 = sin fricciÃ³n, 1 = se detiene ya)
            PLAYER_START_LIFE: 100,       // Vida inicial

            // Laberinto
            MAZE_COLS: 11,                // Columnas del laberinto (debe ser impar)
            MAZE_ROWS: 11,                // Filas del laberinto (debe ser impar)
            CELL_SIZE: 80,                // TamaÃ±o (ancho/largo) de cada celda
            WALL_HEIGHT: 36,              // Altura de los muros
            WALL_THICKNESS: 8,            // Grosor de los muros

            // IA y Enemigos
            ENEMY_COUNT: 8,               // CuÃ¡ntos enemigos crear
            ENEMY_HEALTH: 50,             // Vida de cada enemigo
            ENEMY_SPEED_MIN: 0.8,         // Velocidad mÃ­nima del enemigo
            ENEMY_SPEED_MAX: 1.6,         // Velocidad mÃ¡xima del enemigo
            ENEMY_SIGHT_RANGE: 400,       // Rango de visiÃ³n del enemigo
            ENEMY_ATTACK_RANGE: 15,       // Rango de ataque del enemigo
            ENEMY_ATTACK_DAMAGE: 8,       // DaÃ±o por ataque
            ENEMY_ATTACK_COOLDOWN: 1000,  // Tiempo (ms) entre ataques

            // Juego
            SHOOT_DAMAGE: 30,             // DaÃ±o del disparo del jugador
            SHOOT_RANGE: 50,            // Alcance del disparo
            // Archivos (Rutas a los assets)
            HDR_PATH: 'models/rgbe/fondo.hdr',
            FLOOR_TEX: 'models/rgbe/piso.jpg',
            WALL_TEX: 'models/rgbe/paredes.jpg', // Textura para los muros
        };

        // -------------------------------------------------------------------
        // ---------- Variables Globales del Programa ----------
        // -------------------------------------------------------------------
        let camera, scene, renderer, stats, controls, clock; // NÃºcleo de Three.js
        let controller1, controller2;
        let hudCtx, hudCanvas, hudTexture;

        const keys = {};                 // Objeto para guardar quÃ© teclas estÃ¡n presionadas
        const physicsObjects = [];       // Array de objetos con colisiÃ³n (paredes, enemigos)
        const enemies = [];              // Array para guardar solo los enemigos
        let playerLife = CONFIG.PLAYER_START_LIFE; // Vida actual del jugador

        // Elementos del DOM (HTML) para el HUD
        const lifeEl = document.getElementById('life');
        const enemiesCountEl = document.getElementById('enemiesCount');
        const messageEl = document.getElementById('message');
        const statsContainer = document.getElementById('stats-container');

        // Estado de la fÃ­sica del jugador
        const playerVelocity = new THREE.Vector3(); // Vector de velocidad actual
        let playerOnGround = false;               // Â¿El jugador estÃ¡ en el suelo?
        const playerCollider = new THREE.Box3();  // "Hitbox" (caja de colisiÃ³n) del jugador

        // Utilitarios
        const upVector = new THREE.Vector3(0, 1, 0); // Vector "arriba"
        const raycaster = new THREE.Raycaster();

        // Variables para el modelo 3D del jugador y su animaciÃ³n
        let playerRootBone;                 // Hueso de la cadera (para head-bob)
        let defaultRootY = 0;               // PosiciÃ³n Y inicial del hueso
        let playerModel, mixer, thirdPersonCamera; // El modelo, su "reproductor" y la cÃ¡mara 3ra persona
        const actions = {};                 // Objeto para guardar todas las animaciones (ej. 'Running')
        let actionCurrent = null;           // AnimaciÃ³n que se estÃ¡ reproduciendo ahora
        let wallMaterial;                   // Material global para los muros (eficiencia)


        let controllerRight;
        // Iniciar el juego
        init();
        animate();

        // -------------------------------------------------------------------
        // ---------- 1. INICIALIZACIÃ“N (init) ----------
        // Se ejecuta una sola vez. Configura la escena, carga modelos y crea el laberinto.
        // -------------------------------------------------------------------
        function init() {
            // ConfiguraciÃ³n bÃ¡sica de la escena
            clock = new THREE.Clock();          // Reloj para medir el tiempo (delta time)
            scene = new THREE.Scene();          // La escena principal
            scene.fog = new THREE.Fog(0xcccccc, 400, 1300); // Niebla

            // CÃ¡mara principal (FPS)
            // FOV 60, Aspect Ratio, Near Plane 1 (evita "pared blanca"), Far Plane 3000
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
            
            // Renderizador (dibuja la escena en el <canvas>)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Activar sombras
           // --- ACTIVAR VR ---
        renderer.xr.enabled = true;
        document.body.appendChild(VRButton.createButton(renderer));
        document.body.appendChild(renderer.domElement);

        // === CONTROLES VR (META QUEST 3) ===

        // Creamos ambos controllers (Quest los asigna automÃ¡ticamente)
        controller1 = renderer.xr.getController(0);
        controller2 = renderer.xr.getController(1);

        // Identificar cuÃ¡l es la mano derecha y activar el gatillo
        controller1.addEventListener('connected', (event) => {
            if (event.data.handedness === 'right') {
                controllerRight = controller1;
                controllerRight.addEventListener('selectstart', handleShoot);
                console.log("Control derecho conectado en controller1");
            }
        });

        controller2.addEventListener('connected', (event) => {
            if (event.data.handedness === 'right') {
                controllerRight = controller2;
                controllerRight.addEventListener('selectstart', handleShoot);
                console.log("Control derecho conectado en controller2");
            }
        });

        // AÃ±adimos ambos a la escena (aunque solo usamos uno)
        scene.add(controller1);
        scene.add(controller2);



            // Medidor de FPS
            stats = new Stats();
            statsContainer.appendChild(stats.dom);

            // CÃ¡mara de 3ra persona (para la esquina)
            const aspect = (window.innerWidth * 0.25) / (window.innerHeight * 0.25);
            thirdPersonCamera = new THREE.PerspectiveCamera(50, aspect, 1, 1000);
            scene.add(thirdPersonCamera);

            // Carga de Texturas y Materiales (se hace 1 vez para eficiencia)
            const texLoader = new THREE.TextureLoader();
            const wallMap = texLoader.load(CONFIG.WALL_TEX);
            wallMap.wrapS = wallMap.wrapT = THREE.RepeatWrapping;
            wallMap.repeat.set(1, 1);

            wallMaterial = new THREE.MeshStandardMaterial({
                map: wallMap,
                roughness: 0.8,
                metalness: 0.2
            });

            // Carga del Modelo 3D del Jugador (FBX)
            const fbx = new FBXLoader();
            const animLoader = new FBXLoader(); // Cargador separado para las animaciones
            const charPath = 'models/fbx/Jab Cross.fbx'; // Modelo base (contiene la malla)
            
            // Lista de animaciones a cargar (nombre, ruta)
            const animationFiles = [
                ['Running',           'models/fbx/Running.fbx'],
                ['Running Up Stairs', 'models/fbx/Running Up Stairs.fbx'],
                ['Jump',              'models/fbx/Jump.fbx'],
                ['Walking',           'models/fbx/Walking.fbx']
            ];

            // 1. Cargar el modelo principal
            fbx.load(charPath, (fbxScene) => {
                playerModel = fbxScene;
                // Escalar el modelo para que coincida con nuestra altura de jugador
                const modelHeight = 150; // Altura aprox. de un modelo Mixamo
                const targetScale = CONFIG.PLAYER_HEIGHT / modelHeight;
                playerModel.scale.set(targetScale, targetScale, targetScale); 
                
                playerModel.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;    // El jugador arroja sombra
                        c.receiveShadow = false; // Pero no recibe sombra (se ve raro en FPS)
                    }
                });

                // Encontrar el hueso "Hips" (cadera) para el efecto de bamboleo (head-bob)
                playerModel.traverse(c => {
                    if (c.isBone && (c.name.includes('Hips') || c.name.includes('hips') || c.name.includes('mixamorig:Hips'))) {
                        playerRootBone = c;
                        console.log("Hueso raÃ­z encontrado:", c.name);
                    }
                });
                
                if (playerRootBone) {
                    defaultRootY = playerRootBone.position.y; // Guardar altura inicial del hueso
                } else {
                    console.warn("No se encontrÃ³ el hueso 'Hips'. El 'head bob' no funcionarÃ¡.");
                    const boneNames = [];
                    playerModel.traverse(c => { if (c.isBone) boneNames.push(c.name); });
                    console.log("Huesos disponibles:", boneNames); // Log para depuraciÃ³n
                }

                // 2. Crear el "reproductor" (Mixer) para este modelo
                mixer = new THREE.AnimationMixer(playerModel);

                // 3. Cargar la animaciÃ³n que viene DENTRO del modelo principal
                if (fbxScene.animations && fbxScene.animations.length > 0) {
                    const mainClip = fbxScene.animations[0];
                    actions['Jab Cross'] = mixer.clipAction(mainClip);
                    console.log(`AnimaciÃ³n base cargada: ${mainClip.name} (guardada como 'Jab Cross')`);
                } else {
                    console.warn("El modelo principal (Jab Cross.fbx) no contenÃ­a animaciones.");
                }

                // 4. Cargar todas las demÃ¡s animaciones por separado
                animationFiles.forEach(([name, path]) => {
                    animLoader.load(path, (animFbx) => {
                        if (animFbx.animations && animFbx.animations.length > 0) {
                            const clip = animFbx.animations[0];
                            // AÃ±adir este clip al mixer del *jugador principal*
                            actions[name] = mixer.clipAction(clip);
                            console.log(`AnimaciÃ³n cargada: '${name}' desde ${path}`);
                        } else {
                            console.warn(`El archivo de animaciÃ³n ${path} no contenÃ­a clips.`);
                        }
                    }, undefined, err => console.warn(`Error cargando animaciÃ³n ${path}:`, err));
                });

                // 5. Iniciar con la animaciÃ³n por defecto
                if (actions['Jab Cross']) {
                    playAction('Jab Cross');
                } else if (fbxScene.animations.length > 0) {
                    const defaultAnimName = fbxScene.animations[0].name;
                    playAction(defaultAnimName);
                } else {
                    console.warn("No hay animaciÃ³n por defecto para reproducir.");
                }
                
                // 6. AÃ±adir el modelo (invisible por ahora) a la escena
                scene.add(playerModel);

            }, undefined, err => console.warn('No se cargÃ³ el modelo del jugador:', err));


            // Controles FPS (PointerLock)
            controls = new PointerLockControls(camera, renderer.domElement);
            // Listener para bloquear el cursor al hacer clic
            document.body.addEventListener('click', () => {
                if (playerLife > 0) {
                     controls.lock(); // Bloquear cursor
                }
            });
           // controls.addEventListener('lock', () => showMessage('Controles desbloqueados', 1500));
            //controls.addEventListener('unlock', () => showMessage('Controles bloqueados', 1500));
            // AÃ±adir el "objeto" de controles (la cÃ¡mara) a la escena
            scene.add(controls.getObject());

            // ---------- HUD 3D VR (con vida, enemigos y objetivo) ----------
            hudCanvas = document.createElement('canvas');
            hudCanvas.width = 512;
            hudCanvas.height = 256;

            hudCtx = hudCanvas.getContext('2d');

            hudTexture = new THREE.CanvasTexture(hudCanvas);
            const hudMaterial = new THREE.MeshBasicMaterial({
                map: hudTexture,
                transparent: true
            });

            const hudPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.75),
                hudMaterial
            );
            hudPlane.position.set(0, 0, -2);

            // Lo aÃ±adimos a la cÃ¡mara (HUD fijo en VR)
            camera.add(hudPlane);
            scene.add(camera);


            // ConfiguraciÃ³n de Luces
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Luz ambiental suave
            scene.add(hemi);
            const sun = new THREE.DirectionalLight(0xffffff, 1.0); // Sol (luz direccional)
            sun.position.set(100, 300, 100);
            sun.castShadow = true; // El sol arroja sombras
            // ConfiguraciÃ³n de la calidad de las sombras
            sun.shadow.mapSize.width = 1024;
            sun.shadow.mapSize.height = 1024;
            scene.add(sun);

            // Piso
            const floorMap = texLoader.load(CONFIG.FLOOR_TEX);
            floorMap.wrapS = floorMap.wrapT = THREE.RepeatWrapping; // Repetir textura
            floorMap.repeat.set(12, 12); // 12x12 repeticiones
            const floorMat = new THREE.MeshStandardMaterial({ map: floorMap, roughness: 0.9 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), floorMat);
            floor.rotation.x = -Math.PI / 2; // Rotar para que estÃ© horizontal
            floor.receiveShadow = true; // El piso recibe sombras
            scene.add(floor);

            // Cielo (HDR)
            new RGBELoader().load(CONFIG.HDR_PATH, tex => {
                tex.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = tex; // Para reflejos
                scene.background = tex;  // Como fondo
            }, undefined, err => console.warn('HDR no cargado:', err));

            // --- CreaciÃ³n del Nivel ---
            generateMaze(CONFIG.MAZE_ROWS, CONFIG.MAZE_COLS, CONFIG.CELL_SIZE);
            spawnEnemiesInMaze(CONFIG.ENEMY_COUNT);
            createGoalAtEnd();
            
            // --- Posicionar al Jugador ---
            // (Se hace DESPUÃ‰S de generateMaze para que scene.userData.maze exista)
            const maze = scene.userData.maze;
            if (maze) {
                camera.position.set(
                    maze.startX + CONFIG.CELL_SIZE / 2, // Centro de la celda inicial (X)
                    CONFIG.PLAYER_HEIGHT * 0.8,         // Altura de los ojos
                    maze.startZ + CONFIG.CELL_SIZE / 2  // Centro de la celda inicial (Z)
                );
            } else {
                console.error("Error: No se pudo generar el laberinto, el jugador no se posicionÃ³.");
            }


            // --- Event Listeners (Entradas de usuario) ---
            window.addEventListener('resize', onWindowResize); // Redimensionar ventana
            window.addEventListener('keydown', onKeyDown);     // Tecla presionada
            window.addEventListener('keyup', onKeyUp);         // Tecla soltada
            // Disparo solo con 'F'
            window.addEventListener('keydown', (e) => { if (e.code === 'KeyF') handleShoot(); });
        }

        // -------------------------------------------------------------------
        // ---------- 2. GENERACIÃ“N DEL LABERINTO ----------
        // -------------------------------------------------------------------
        function generateMaze(rows, cols, cellSize) {
            // (ImplementaciÃ³n del algoritmo "Recursive Backtracker" para crear la grilla)
            const grid = [];
            for(let r=0;r<rows;r++){ grid[r] = []; for(let c=0;c<cols;c++){ grid[r][c] = { r, c, visited:false, walls: [true,true,true,true] }; }}
            const stack = []; let current = grid[0][0]; current.visited = true;
            function neighbors(cell){ const n = []; const {r,c} = cell; if(r>0 && !grid[r-1][c].visited) n.push(grid[r-1][c]); if(c<cols-1 && !grid[r][c+1].visited) n.push(grid[r][c+1]); if(r<rows-1 && !grid[r+1][c].visited) n.push(grid[r+1][c]); if(c>0 && !grid[r][c-1].visited) n.push(grid[r][c-1]); return n; }
            while(true){ const n = neighbors(current); if(n.length>0){ const next = n[Math.floor(Math.random()*n.length)]; stack.push(current); const dr = next.r - current.r; const dc = next.c - current.c; if(dr === -1){ current.walls[0] = false; next.walls[2] = false; } if(dc === 1){ current.walls[1] = false; next.walls[3] = false; } if(dr === 1){ current.walls[2] = false; next.walls[0] = false; } if(dc === -1){ current.walls[3] = false; next.walls[1] = false; } current = next; current.visited = true; } else if(stack.length>0){ current = stack.pop(); } else break; }

            // --- ConstrucciÃ³n de Muros 3D ---
            const startX = -(cols * cellSize) / 2;
            const startZ = -(rows * cellSize) / 2;
            const wallHeightHalf = CONFIG.WALL_HEIGHT / 2;

            // GeometrÃ­a ÃšNICA para todos los muros (eficiente)
            // Se hace mÃ¡s larga (cellSize + thickness) para que se traslapen en las esquinas y no haya huecos
            const wallGeo = new THREE.BoxGeometry(
                cellSize + CONFIG.WALL_THICKNESS, 
                CONFIG.WALL_HEIGHT, 
                CONFIG.WALL_THICKNESS
            );

            // FunciÃ³n auxiliar para crear un muro
            const createWall = (posX, posZ, rotY) => {
                const wall = new THREE.Mesh(wallGeo, wallMaterial); // Usa el material global
                wall.position.set(posX, wallHeightHalf, posZ);
                wall.rotation.y = rotY;
                wall.receiveShadow = true;
                wall.castShadow = true;
                scene.add(wall);
                
                // Crear y guardar el Bounding Box (caja de colisiÃ³n) del muro
                wall.updateMatrixWorld();
                const wallBox = new THREE.Box3().setFromObject(wall);
                physicsObjects.push({ mesh: wall, boundingBox: wallBox, static: true });
            
                // Ajustar repeticiÃ³n de textura para que no se estire
                if (wall.material.map) {
                    wall.material.map.repeat.set(1, CONFIG.WALL_HEIGHT / (CONFIG.WALL_THICKNESS * 2));
                }
            };

            // Iterar sobre la grilla y crear los muros 3D
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = grid[r][c];
                    const cx = startX + c * cellSize + cellSize / 2;
                    const cz = startZ + r * cellSize + cellSize / 2;

                    // Centrar los muros en los bordes de la celda
                    if (cell.walls[0]) createWall(cx, cz - cellSize / 2, 0); // Norte
                    if (cell.walls[1]) createWall(cx + cellSize / 2, cz, Math.PI / 2); // Este
                    if (cell.walls[2]) createWall(cx, cz + cellSize / 2, 0); // Sur
                    if (cell.walls[3]) createWall(cx - cellSize / 2, cz, Math.PI / 2); // Oeste
                }
            }
            // Guardar la data del laberinto para uso futuro (posicionar jugador)
            scene.userData.maze = { grid, startX, startZ, rows, cols, cellSize };
        }

        // -------------------------------------------------------------------
        // ---------- 3. SPAWN DE ENEMIGOS ----------
        // -------------------------------------------------------------------
        function spawnEnemiesInMaze(count) {
            const maze = scene.userData.maze;
            if (!maze) return; // Seguridad si el laberinto no existe
            const { startX, startZ, rows, cols, cellSize } = maze;

            // GeometrÃ­a y material para los enemigos (bloques rojos)
            const enemyGeo = new THREE.BoxGeometry(15, 15, 15);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xdd4444, roughness: 0.8 });

            let placed = 0;
            while (placed < count) {
                // Elegir una celda aleatoria (r, c)
                const r = 1 + Math.floor(Math.random() * (rows - 2));
                const c = 1 + Math.floor(Math.random() * (cols - 2));
                const x = startX + c * cellSize + cellSize / 2;
                const z = startZ + r * cellSize + cellSize / 2;

                // Evitar spawn cerca del inicio
                if (Math.hypot(x - (startX + cellSize / 2), z - (startZ + cellSize / 2)) < cellSize) continue;

                // Crear el enemigo
                const enemy = new THREE.Mesh(enemyGeo, enemyMat); 
                enemy.position.set(x, 7.5, z); // Posicionar en el suelo
                enemy.castShadow = true;
                enemy.receiveShadow = true;
                
                // Guardar datos Ãºtiles en el enemigo (vida, velocidad, etc.)
                enemy.userData = { 
                    health: CONFIG.ENEMY_HEALTH, 
                    alive: true, 
                    speed: CONFIG.ENEMY_SPEED_MIN + Math.random() * (CONFIG.ENEMY_SPEED_MAX - CONFIG.ENEMY_SPEED_MIN) 
                };
                scene.add(enemy);
                
                // Crear y guardar su Bounding Box para colisiones
                enemy.updateMatrixWorld();
                const enemyBox = new THREE.Box3().setFromObject(enemy);

                enemies.push(enemy); // AÃ±adir a la lista de enemigos
                physicsObjects.push({ mesh: enemy, boundingBox: enemyBox, mass: 50 }); // AÃ±adir a la lista de colisiones
                placed++;
            }
            updateEnemiesHUD(); // Actualizar contador
        }

        // -------------------------------------------------------------------
        // ---------- 4. CREAR PORTAL (META) ----------
        // -------------------------------------------------------------------
        function createGoalAtEnd(){
            const maze = scene.userData.maze;
            if(!maze) return;
            const { startX, startZ, rows, cols, cellSize } = maze;
            // Posicionar en la esquina opuesta (Ãºltima celda)
            const gx = startX + (cols-1)*cellSize + cellSize/2;
            const gz = startZ + (rows-1)*cellSize + cellSize/2;

            // Crear un toroide (dona) verde brillante
            const portalGeo = new THREE.TorusGeometry(30, 6, 16, 100);
            const portalMat = new THREE.MeshStandardMaterial({ color:0x22ff88, emissive:0x22ff88, emissiveIntensity:0.3 });
            const portal = new THREE.Mesh(portalGeo, portalMat);
            portal.rotation.x = Math.PI/2; // Rotar para que estÃ© vertical
            portal.position.set(gx, 45, gz);
            scene.add(portal);
            // Guardar su posiciÃ³n para la detecciÃ³n de "victoria"
            scene.userData.goal = { mesh: portal, position: new THREE.Vector3(gx,0,gz) };
        }

        // -------------------------------------------------------------------
        // ---------- 5. LÃ“GICA DE DISPARO ----------
        // -------------------------------------------------------------------
        function handleShoot() {
    if (!controls.isLocked) return;

    const origin = camera.position.clone();
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);

    raycaster.set(origin, dir);
    raycaster.far = CONFIG.SHOOT_RANGE;

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
        const hit = intersects[0];
        console.log("ðŸ”¥ Impacto en:", hit.object.name);
    }
}



        // -------------------------------------------------------------------
        // ---------- 6. APLICAR DAÃ‘O A ENEMIGO ----------
        // -------------------------------------------------------------------
        function applyDamageToEnemy(enemy, amount) {
        if (!enemy.userData) return;
        enemy.userData.health -= amount;

        // Parpadeo rojo
        enemy.material.emissive = new THREE.Color(0xff0000);
        setTimeout(() => { 
            if (enemy.material) enemy.material.emissive = new THREE.Color(0x000000);
        }, 120);

        // Â¿MuriÃ³?
        if (enemy.userData.health <= 0 && enemy.userData.alive) {
            enemy.userData.alive = false;

            //SONIDO DE MUERTE
            if (enemyDeathSound) {
                enemyDeathSound.currentTime = 0;
                enemyDeathSound.play();
            }

            enemy.rotation.z = Math.PI / 2;
            enemy.material.color.set(0x333333);

            // Quitar de la fÃ­sica
            const idx = physicsObjects.findIndex(p => p.mesh === enemy);
            if (idx >= 0) physicsObjects.splice(idx, 1);

            setTimeout(() => { 
                scene.remove(enemy); 
                updateEnemiesHUD(); 
            }, 1200);
        }

        updateEnemiesHUD();
    }

        // -------------------------------------------------------------------
        // ---------- 7. MANEJO DE ENTRADAS (Input) ----------
        // -------------------------------------------------------------------

        // (onMouseDown estÃ¡ comentado porque se eliminÃ³ el disparo con clic)
        /*function onMouseDown(e) {
            if (e.button === 0 && controls.isLocked) handleShoot();
        }*/

        function onKeyDown(e) { 
            // 'keys' se usa para movimiento (polling), se mantiene presionado
            keys[e.code] = true;
            
            // 'switch' se usa para acciones de una sola vez (eventos)
            switch (e.code) {
                case 'Digit1': playAction('Jab Cross'); break;
                case 'Digit2': playAction('Running'); break;
                case 'Digit3': playAction('Running Up Stairs'); break;
                case 'Digit4': playAction('Jump'); break;
                case 'Digit5': playAction('Walking'); break;
            }
        }
        function onKeyUp(e) { 
            // Marcar la tecla como "suelta"
            keys[e.code] = false; 
        }

        // -------------------------------------------------------------------
        // ---------- 8. FUNCIONES DEL HUD Y MENSAJES ----------
        // -------------------------------------------------------------------
        
        // Actualiza el contador de enemigos en el HUD
        function updateEnemiesHUD() {
            const alive = enemies.filter(e => e.userData && e.userData.alive).length;
            enemiesCountEl.textContent = alive;
        }

        // Muestra un mensaje en el centro de la pantalla
        function showMessage(text, ms = 3000) {
            messageEl.style.display = 'block';
            messageEl.innerHTML = text; // Usamos innerHTML para permitir saltos de lÃ­nea con <br>
            if (ms > 0) setTimeout(() => { messageEl.style.display = 'none'; }, ms);
        }

        // -------------------------------------------------------------------
        // ---------- 9. FÃSICA Y LÃ“GICA DE IA (ENEMIGOS) ----------
        // Se ejecuta en cada frame, maneja la IA y el daÃ±o al jugador
        // -------------------------------------------------------------------
        function stepPhysics(dt) {
            const playerPos = camera.position;

            for (const en of enemies) {
                if (!en.userData || !en.userData.alive) continue; // Saltar si estÃ¡ muerto

                const enemyPhysObj = physicsObjects.find(p => p.mesh === en);
                const toPlayer = new THREE.Vector3().subVectors(playerPos, en.position);
                const dist = toPlayer.length();

                // 1. Comprobar rango de visiÃ³n
                if (dist < CONFIG.ENEMY_SIGHT_RANGE) {
                    toPlayer.normalize(); // DirecciÃ³n hacia el jugador
                    
                    // 2. Comprobar lÃ­nea de visiÃ³n (Raycaster)
                    raycaster.set(en.position, toPlayer);
                    raycaster.far = dist;
                    const hits = raycaster.intersectObjects(physicsObjects.filter(p => p.static).map(p => p.mesh));

                    // Si no hay 'hits' o el primer hit estÃ¡ MÃS LEJOS que el jugador, hay lÃ­nea de visiÃ³n
                    if (hits.length === 0 || hits[0].distance >= dist - 1) {
                        
                        // 3. Moverse hacia el jugador
                        toPlayer.y = 0; // No volar
                        en.position.addScaledVector(toPlayer, en.userData.speed * dt * 60);
                        
                        // Actualizar la Bounding Box del enemigo
                        if(enemyPhysObj) enemyPhysObj.boundingBox.setFromObject(en);

                        // 4. Atacar al jugador
                        // (Â¡IMPORTANTE! Recalcular la distancia DESPUÃ‰S de moverse)
                        const newDist = playerPos.distanceTo(en.position);
                        
                        if (newDist < CONFIG.ENEMY_ATTACK_RANGE) {
                            // Comprobar cooldown del ataque
                            if (!en.userData._lastAttack || (performance.now() - en.userData._lastAttack) > CONFIG.ENEMY_ATTACK_COOLDOWN) {
                                en.userData._lastAttack = performance.now(); // Resetear cooldown
                                playerLife -= CONFIG.ENEMY_ATTACK_DAMAGE; // Bajar vida
                                if (playerLife < 0) playerLife = 0;
                                lifeEl.textContent = playerLife; // Actualizar HUD
                                if (playerLife <= 0) onPlayerDead(); // Comprobar muerte
                            }
                        }
                    }
                }
            }
        }

        // -------------------------------------------------------------------
        // ---------- 10. FUNCIONES DE ESTADO DEL JUGADOR ----------
        // -------------------------------------------------------------------
        
        // Se llama cuando la vida del jugador llega a 0
        function onPlayerDead() {
            showMessage('- GAME OVER -\n<span style="font-size: 18px">Reinicia la pÃ¡gina para volver a jugar</span>', 10000);
            controls.unlock(); // Desbloquear cursor
            // (Comentado porque onMouseDown fue eliminado)
            // window.removeEventListener('mousedown', onMouseDown);
        }

        // Cambia la animaciÃ³n del jugador suavemente
        function playAction(name) {
            if (actionCurrent && actionCurrent.name === name) return; // No hacer nada si ya es esa

            const newAction = actions[name];
            if (!newAction) {
                console.warn(`No se encontrÃ³ la animaciÃ³n: ${name}`);
                return;
            }

            // Preparar la nueva acciÃ³n
            newAction.reset();
            newAction.setLoop(THREE.LoopRepeat, Infinity); // Asumir que loopea
            newAction.play();

            // TransiciÃ³n suave (cross-fade)
            if (actionCurrent) {
                actionCurrent.crossFadeTo(newAction, 0.3, true);
            }

            actionCurrent = newAction;
            actionCurrent.name = name; // Guardar nombre para la prÃ³xima comprobaciÃ³n
        }


        // -------------------------------------------------------------------
        // ---------- 11. FÃSICA Y MOVIMIENTO DEL JUGADOR ----------
        // Se ejecuta en cada frame. Mueve al jugador y comprueba colisiones
        // -------------------------------------------------------------------
    function updatePlayerMovement(dt) {
        const speed = CONFIG.PLAYER_SPEED; // Puedes aÃ±adir sprint si quieres con un botÃ³n del controlador
        const moveForward = new THREE.Vector3();
        const moveRight = new THREE.Vector3();

        // DirecciÃ³n hacia donde mira la cÃ¡mara
        camera.getWorldDirection(moveForward);
        moveForward.y = 0;
        moveForward.normalize();
        moveRight.crossVectors(new THREE.Vector3(0,1,0), moveForward).normalize();

        // --- Input VR ---
        let vrDir = new THREE.Vector3(0, 0, 0);

        if (controller1 && controller1.userData.gamepad) {
            const gp = controller1.userData.gamepad;
            // gp.axes[2] -> izquierda/derecha, gp.axes[3] -> adelante/atrÃ¡s
            vrDir.x = gp.axes[2]; // izquierda/derecha
            vrDir.z = gp.axes[3]; // adelante/atrÃ¡s
        }

        // Aplicar movimiento horizontal basado en joystick
        playerVelocity.x += moveRight.x * -vrDir.x * speed * dt + moveForward.x * -vrDir.z * speed * dt;
        playerVelocity.z += moveRight.z * -vrDir.x * speed * dt + moveForward.z * -vrDir.z * speed * dt;

        // Aplicar gravedad
        playerVelocity.y += CONFIG.GRAVITY * dt;

        // --- LÃ³gica de ColisiÃ³n (AABB) ---
        const delta = playerVelocity.clone().multiplyScalar(dt);
        const playerHalfHeight = CONFIG.PLAYER_HEIGHT / 2;

        // 1. Actualizar hitbox
        playerCollider.setFromCenterAndSize(
            camera.position,
            new THREE.Vector3(CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT, CONFIG.PLAYER_WIDTH)
        );

        // 2. ColisiÃ³n eje Y
        const futureYCollider = playerCollider.clone().translate(new THREE.Vector3(0, delta.y, 0));
        let playerOnGround = false;

        for (const obj of physicsObjects) {
            if (futureYCollider.intersectsBox(obj.boundingBox)) {
                if (playerVelocity.y < 0) {
                    playerOnGround = true;
                    camera.position.y = obj.boundingBox.max.y + playerHalfHeight;
                }
                playerVelocity.y = 0;
                delta.y = 0;
                break;
            }
        }

        // 3. ColisiÃ³n eje X
        const futureXCollider = playerCollider.clone().translate(new THREE.Vector3(delta.x, 0, 0));
        for (const obj of physicsObjects) {
            if (futureXCollider.intersectsBox(obj.boundingBox)) {
                playerVelocity.x = 0;
                delta.x = 0;
                break;
            }
        }

        // 4. ColisiÃ³n eje Z
        const futureZCollider = playerCollider.clone().translate(new THREE.Vector3(0, 0, delta.z));
        for (const obj of physicsObjects) {
            if (futureZCollider.intersectsBox(obj.boundingBox)) {
                playerVelocity.z = 0;
                delta.z = 0;
                break;
            }
        }

        // 5. Aplicar movimiento
        camera.position.add(delta);

        // 6. Evitar caer por debajo del suelo
        if (camera.position.y < playerHalfHeight) {
            playerVelocity.y = 0;
            camera.position.y = playerHalfHeight;
            playerOnGround = true;
        }

        // 7. Chequear llegada a la meta
        const goal = scene.userData.goal;
        if (goal && playerLife > 0) {
            const distGoal = camera.position.distanceTo(goal.position);
            if (distGoal < 50) {
                showMessage('Â¡GANASTE!\n<span style="font-size: 18px">Llegaste al portal</span>', 7000);
                controls.unlock();
                playerLife = -1; // Evitar ganar/morir de nuevo
            }
        }

        // --- Saltar (botÃ³n del controlador) ---
        if (controller1 && controller1.userData.gamepad) {
            const gp = controller1.userData.gamepad;
            // Suponiendo botÃ³n 0 (trigger principal) como salto
            if (gp.buttons[0].pressed && playerOnGround) {
                playerVelocity.y = CONFIG.PLAYER_JUMP_FORCE;
                playerOnGround = false;
            }
        }
    }


        // -------------------------------------------------------------------
        // ---------- 12. LOOP PRINCIPAL (animate) ----------
        // Se ejecuta 60 veces por segundo. Mueve todo y dibuja la pantalla.
        // -------------------------------------------------------------------
        // -------------------------------------------------------------------

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(); // Obtener el tiempo desde el Ãºltimo frame

            // 1. Actualizar LÃ³gica (FÃ­sica, IA, Animaciones)
            if (playerLife > 0) { // Solo actualizar si el jugador estÃ¡ vivo
                updatePlayerMovement(dt);
                stepPhysics(dt);
            }
            if (mixer) mixer.update(dt); // Actualizar animaciones
            updateHUD(); // actualizar HUD 3D

            renderer.render(scene, camera);

            // 2. Sincronizar modelo 3D con la cÃ¡mara FPS
            if (playerModel) {
                playerModel.position.copy(camera.position);
                playerModel.quaternion.copy(camera.quaternion);
                // Ajuste visual para alinear el modelo 3D con la cÃ¡mara
                playerModel.position.y -= CONFIG.PLAYER_HEIGHT / 2 - 2; 
            }

            // 3. Sincronizar la cÃ¡mara de tercera persona (de la esquina) solo si NO es VR
            if (!renderer.xr.isPresenting && playerModel && thirdPersonCamera) {
                const offset = new THREE.Vector3(0, 40, 60); // Distancia detrÃ¡s y arriba
                offset.applyQuaternion(playerModel.quaternion); // Rotar el offset con el jugador
                thirdPersonCamera.position.copy(playerModel.position).add(offset);
                thirdPersonCamera.lookAt(playerModel.position.clone().add(new THREE.Vector3(0, 20, 0))); // Mirar al pecho
            }

            // 4. Renderizado
            renderer.autoClear = false; // Desactivar limpieza automÃ¡tica
            renderer.clear();

            // --- Calcular el "Head Bob" solo para no VR ---
            let bobOffset = 0;
            if (!renderer.xr.isPresenting && playerRootBone && playerModel && playerLife > 0) {
                const currentRootY = playerRootBone.position.y;
                bobOffset = (currentRootY - defaultRootY) * playerModel.scale.y;
            }

            // --- RENDER PRINCIPAL ---
            if (!renderer.xr.isPresenting) {
                // FPS normal
                if (playerModel) playerModel.visible = false; // Invisible en 1ra persona

                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissorTest(true);

                camera.position.y += bobOffset;
                renderer.render(scene, camera);
                camera.position.y -= bobOffset;
            } else {
                // VR: renderiza automÃ¡ticamente ambos ojos
                renderer.render(scene, camera);
            }

            // --- RENDER 2: Vista de esquina (solo no VR) ---
            if (!renderer.xr.isPresenting && playerModel && thirdPersonCamera) {
                playerModel.visible = true; // Visible en 3ra persona
                const w = window.innerWidth * 0.20;
                const h = window.innerHeight * 0.20;
                const x = window.innerWidth - w - 20;
                const y = 20;

                renderer.clearDepth(); // Limpiar solo la profundidad
                renderer.setViewport(x, y, w, h);
                renderer.setScissor(x, y, w, h);
                renderer.setScissorTest(true);

                renderer.render(scene, thirdPersonCamera);
            }

            renderer.autoClear = true; // Reactivar limpieza
            stats.update(); // Actualizar medidor de FPS
        }

        // ---------------------------------------------------
        // ConfiguraciÃ³n para VR
        // ---------------------------------------------------
        renderer.xr.enabled = true; // Activar VR
        document.body.appendChild(VRButton.createButton(renderer)); // BotÃ³n de entrada a VR
        renderer.setAnimationLoop(animate); // Llama a animate automÃ¡ticamente en VR


        // -------------------------------------------------------------------
        // ---------- 13. UTILIDADES ----------
        // -------------------------------------------------------------------
        
        // Se llama cuando el usuario cambia el tamaÃ±o de la ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        
            // Actualizar tambiÃ©n la cÃ¡mara de la esquina
            if (thirdPersonCamera) {
                const w = window.innerWidth * 0.20;
                const h = window.innerHeight * 0.20;
                thirdPersonCamera.aspect = w / h;
                thirdPersonCamera.updateProjectionMatrix();
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        // 4ï¸âƒ£ FunciÃ³n para actualizar HUD
        function updateHUD() {
            hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);

            // Fondo semi-transparente
            hudCtx.fillStyle = 'rgba(0,0,0,0.5)';
            hudCtx.fillRect(0, 0, hudCanvas.width, hudCanvas.height);

            // Vida del jugador
            hudCtx.fillStyle = 'white';
            hudCtx.font = '48px Arial';
            hudCtx.fillText(`Vida: ${playerLife}`, 20, 60);

            // Enemigos restantes
            const aliveEnemies = enemies.filter(e => e.userData && e.userData.alive).length;
            hudCtx.fillText(`Enemigos: ${aliveEnemies}`, 20, 120);

            // Objetivo
            hudCtx.font = '28px Arial';
            hudCtx.fillStyle = 'yellow';
            hudCtx.fillText('Objetivo: llegar al portal al final del laberinto', 20, 180);

            // Mensaje temporal (opcional)
            if (messageEl.textContent) {
                hudCtx.fillStyle = 'cyan';
                hudCtx.font = '32px Arial';
                hudCtx.fillText(messageEl.textContent, 20, 220);
            }

            hudTexture.needsUpdate = true;
        }

            document.getElementById("startBtn").addEventListener("click", () => {
            document.getElementById("portada").style.opacity = "0";
            setTimeout(() => {
                document.getElementById("portada").style.display = "none";
            }, 500);
        });
</script>

</body>
</html>